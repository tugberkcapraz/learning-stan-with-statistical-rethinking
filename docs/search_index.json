[["index.html", "Learning Stan with Statistical Retinking Chapter 1 Geocentric Models 1.1 Linear Prediction 1.2 Polynomial Stan", " Learning Stan with Statistical Retinking Kerem Tugberk Capraz 2021-07-15 Chapter 1 Geocentric Models library(rethinking) library(dplyr) library(tidyr) library(rstan) library(ggplot2) library(ggthemes) library(gridExtra) library(grid) library(tidybayes) library(tidyverse) library(bayesplot) library(splines) library(purrr) library(stringr) library(brms) data(Howell1) d &lt;- Howell1 d2 &lt;- d[ d$age &gt;= 18 , ] McElreath’s linear model is as follows: \\[h_i \\sim \\textrm{Normal} (\\mu, \\sigma)\\\\ \\ \\ \\ \\ \\ \\ \\mu \\sim \\textrm{Normal(178, 20)}\\\\ \\ \\ \\sigma \\sim \\textrm{Uniform(0,50)}\\] Before doing anything let’s visually understand what \\[\\mu \\sim \\textrm{Normal(178, 20)}\\] means curve(dnorm(x, 178, 20), from = 100, to=250) This is how a normal distribution with mean of 178 and standard deviation of 20 looks like. So we started doing something already. Now let’s visualise \\[\\sigma \\sim \\textrm{Uniform(0, 50)}\\] curve(dunif(x, 0, 50), from=-10, to=60) Everything looks cool so far. Now it’s time to simulate fake height numbers implied by these priors. What we are going to do is using ‘rnorm’ and ‘runif’ functions with the numbers given us by McElreath. prior_mu and prior_sigma are the random numbers generated for mu and sigma when we plug the numbers. prior_height_sim is again using rnorm, but this time rather than setting an arbitrary number for mean and sd parameters inside the rnorm, we are plugging the derived prior_mu and prior_sigma as mean and sd respectively. then we plot it prior_mu &lt;- rnorm(1e4, 178, 20) prior_sigma &lt;- runif(1e4, 0, 50) prior_height_sim &lt;- rnorm(1e4, prior_mu, prior_sigma) dens(prior_height_sim) As you can see the resulting distribution of height is plausible. In order to see what happens under different prior description of the height, we this time tweak the standard deviation of prior mu \\[\\mu \\sim \\textrm{Normal(178, 100)}\\] Let’s see what happens prior_mu &lt;- rnorm(1e4, 178, 100) prior_height_sim &lt;- rnorm(1e4, prior_mu, prior_sigma) dens(prior_height_sim) Oh my god! This is horrible. Uncertainty is good, however this doesn’t mean that we have to introduce this sort of ridiculous uncertainty into our models. We all know that there are no people around 400 cm tall. Moreover, this distribution also implies that some people have negative heights! Bad prior. Don’t use it. Now it’s time to use magnificent Stan language for the first time. Fasten your seatbelts. During the course of these notebooks I will write inline stan codes. I normally don’t do it this way. When working with stan, if you separate your scripts and stan files, then, someone else using pystan juliastan etc can easily plug and play with your models in their environments with minimum effort. Plus, it’s also more organized when your stan code is outside of your script. 1.0.1 Using Stan for the First Time When using stan, at first it may seem daunting that you have to do lot of things manually. I understand and to a degree aggree that this is little bit uncomfortable. However, if you really wish to learn what sort of operations that are taken care of when you are using your ordinary statistics package, then, stan is perhaps the best way. Furthermore, even if you have no appetite for learning what’s happening under the hood when you are fitting models, it’s still essential that you have an idea about what goes beneath the surface. Every statistical modelling package or program make decisions on behalf of you. You may call them assumptions or whatever it pleases you. When you know about them, you can start modifying them for your purposes. 1.0.2 Prepare the stan data Stan accepts the data in list format. Whatever you are going to use inside your models must be represented here. stan_data_4_1 &lt;- list(N = NROW(d2), height = d2$height) So, we have only two elements in this list. What are they? N is the number of observations. We are telling stan program how many observations that it should expect.The height is the vector containing height data. There two important points here 1) Naming is up to you. You can call it N or whatever you think it fits. However, once you name it here, you have to stick with that name inside the stan program. Don’t make changes on the fly. And pick names that you can easily remember. This may not seem to be a big issue to you right now. But when the models get complex, then your naming convention will help you. Lets call it clear names principle 2) As you can see, N is just a number. Why didn’t I just pass there the number? It’s related to strategic thinking. In real world applications, unlike these toy examples, the statistical analyses are so rarely linear processes. It doesn’t work in a way that you advance step by step and never return to previous steps. Rather, you try something out. Then you find some discrepancy and you go back to square number one and try different approach (further cleaning, transformation etc.) with your data. So, if you put a constant number there directly, then each time you modified your data you have to make sure that N is still up to date. ‘NROW(d2)’ makes this clear for you. We can call this one don’t hard code principle //What this all means is: //Dear golem, data{ int&lt;lower=1&gt; N; // N is number of observations. I gave you this in the data. vector[N] height; // Height is a vector containing N observations. This is also //in the data } parameters{ real mu; // mu real&lt;lower=0, upper=50&gt; sigma; //sigma // I&#39;ll give details of them in the next block. Just recognize them for now. } model{ height ~ normal(mu, sigma); //height is normally distributed with mu and sigma mu ~ normal(178, 20); //mu is also normally distributed and &quot;I think&quot; mean is //around 178 and since &quot;I think&quot; 138 and 218 are kind of good candidates for //being +-2 standard deviations boundary. sigma ~ uniform(0,50); //sigma is uniformly distributed and can take values between // 0 and 50 } // best regards So, in the comments part I also tried to outline what’s happening inside the stan model by keeping up with McElreath’s Golem analogy. Let’s move on with fitting it. fit_4_1 &lt;- sampling(model_4_1.stan, stan_data_4_1, iter=1000, chains=2, cores=4) print(fit_4_1) ## Inference for Stan model: 027d8e5b047e6b17c3edb7d22b5b286a. ## 2 chains, each with iter=1000; warmup=500; thin=1; ## post-warmup draws per chain=500, total post-warmup draws=1000. ## ## mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat ## mu 154.61 0.02 0.4 153.82 154.35 154.61 154.89 155.42 722 1 ## sigma 7.76 0.01 0.3 7.21 7.55 7.74 7.96 8.36 1017 1 ## lp__ -895.73 0.05 1.0 -898.29 -896.12 -895.45 -895.02 -894.77 414 1 ## ## Samples were drawn using NUTS(diag_e) at Thu Jul 15 23:32:29 2021. ## For each parameter, n_eff is a crude measure of effective sample size, ## and Rhat is the potential scale reduction factor on split chains (at ## convergence, Rhat=1). So it was your first model using stan. Congrats! 1.1 Linear Prediction Our next target, following the book is making use of weight variable to predict heights. Before doing so let’s start with plotting them together. plot( d2$height ~ d2$weight ) There’s an obvious relationship among those 2. Look how height gets bigger as weight gets bigger. Let’s write down the model: \\[h_i \\sim \\textrm{Normal}(\\mu, \\sigma) \\\\ \\ \\ \\mu_i = \\alpha + \\beta_i(x_i - \\bar{x})\\\\ \\ \\ \\ \\ \\ \\alpha \\sim \\textrm{Normal}(178, 20) \\\\ \\ \\ \\beta \\sim \\textrm{Normal}(0, 10)\\\\ \\ \\ \\ \\sigma \\sim \\textrm{Uniform}(0,50)\\] Notice two things. There’s the new parameter \\(\\beta\\).And this is multiplied by \\(x_i -\\bar{x}\\). The latter is called centering. So let’s do that. d2$weight_c &lt;- d2$weight - mean(d2$weight) And prepare the stan data. stan_data_4_3 &lt;- list(N = NROW(d2), height = d2$height, weight_c = d2$weight_c) But maybe we are going too fast. Let’s talk about prior that we set for \\(\\beta\\). Why did we set this? More importantly, do we know what does that imply? \\(\\beta\\) is telling us about the effect. Is Normal(0,10) a good one? One way to know. Let’s plot it N &lt;- 100 # number of lines a &lt;- rnorm(N, 178, 20) # alpha b &lt;- rnorm(N, 0, 10) # beta #plot them plot(NULL, xlim=range(d2$weight), ylim = c(-100, 400), xlab = &quot;weight&quot;, ylab = &quot;height&quot;) abline( h=0 , lty=2 ) # Embryo abline( h=272 , lty=1 , lwd=0.5 ) # World&#39;s tallest person mtext( &quot;b ~ dnorm(0,10)&quot; ) xbar &lt;- mean(d2$weight) for (i in 1:N ) curve(a[i] + b[i]*(x-xbar) , from = min(d2$weight), to=d2$height, add = TRUE, col = col.alpha(&quot;black&quot;, 0.2)) This prior implies that there must be some people with negative weights. Also, from it’s standpoint, 30kg to 400cm decreases to -100cm when the weight gets 60. Not plausible at all. Feel free to try different priors. I’ll shoot one N &lt;- 100 # number of lines a &lt;- rnorm(N, 178, 20) # alpha b &lt;- rnorm(N, 0, 1.5) # beta #plot them plot(NULL, xlim=range(d2$weight), ylim = c(-100, 400), xlab = &quot;weight&quot;, ylab = &quot;height&quot;) abline( h=0 , lty=2 ) # Embryo abline( h=272 , lty=1 , lwd=0.5 ) # World&#39;s tallest person mtext( &quot;b ~ dnorm(0,1.5)&quot; ) xbar &lt;- mean(d2$weight) for (i in 1:N ) curve(a[i] + b[i]*(x-xbar) , from = min(d2$weight), to=d2$height, add = TRUE, col = col.alpha(&quot;black&quot;, 0.2)) Not great, not terrible. Let’s continue with McElreath’s prior. b &lt;- rlnorm(N, 0, 1) # plot the chunk above plot(NULL, xlim=range(d2$weight) , ylim=c(-100,400) , xlab=&quot;weight&quot; , ylab=&quot;height&quot; ) abline( h=0 , lty=2 ) abline( h=272 , lty=1 , lwd=0.5 ) mtext( &quot;b ~ lognorm(0,1)&quot; ) xbar &lt;- mean(d2$weight) for ( i in 1:N ) curve( a[i] + b[i]*(x - xbar) , from=min(d2$weight) , to=max(d2$weight) , add=TRUE , col=col.alpha(&quot;black&quot;,0.2) ) data { int&lt;lower=1&gt; N; vector[N] height; vector[N] weight_c; } parameters { real alpha; real beta; real&lt;lower=0,upper=50&gt; sigma; } model { vector[N] mu = alpha + beta * weight_c; height~ normal(mu, sigma); alpha ~ normal(178, 20); beta ~ lognormal(0, 1); sigma ~ uniform(0,50); } # fit fit_4_3 &lt;- sampling(model_4_3.stan, data = stan_data_4_3, iter = 1000, chains = 2, cores = 2) print(fit_4_3, probs = c(0.1, 0.5, 0.9)) ## Inference for Stan model: 1b47a5d1ac27ee76501545aa74cbaa76. ## 2 chains, each with iter=1000; warmup=500; thin=1; ## post-warmup draws per chain=500, total post-warmup draws=1000. ## ## mean se_mean sd 10% 50% 90% n_eff Rhat ## alpha 154.60 0.01 0.27 154.25 154.60 154.95 1137 1.00 ## beta 0.90 0.00 0.04 0.85 0.90 0.96 1271 1.00 ## sigma 5.10 0.01 0.19 4.86 5.09 5.36 1043 1.01 ## lp__ -748.13 0.05 1.19 -749.62 -747.88 -746.95 638 1.00 ## ## Samples were drawn using NUTS(diag_e) at Thu Jul 15 23:32:54 2021. ## For each parameter, n_eff is a crude measure of effective sample size, ## and Rhat is the potential scale reduction factor on split chains (at ## convergence, Rhat=1). Plotting the posterior against data post &lt;- as.data.frame(fit_4_3) p &lt;- ggplot() + lims(y = c(100, 200)) p1 &lt;- p + geom_point(data = d2, aes(weight_c, height), shape = 1, color = &#39;dodgerblue&#39;) + geom_abline(intercept = mean(post$alpha), slope = mean(post$beta)) + scale_x_continuous(n.breaks = 3, breaks = c(-10, 0, 10), labels = c(30, 45, 55)) p1 Mean at 50 mu_at_50 &lt;- post$alpha + post$beta*50 ggplot() + geom_density(aes(x=mu_at_50), color=&quot;dodgerblue&quot; ) + labs(x = &quot;mu | weight = 50&quot;) Wait a minute it’s not possible! What’s happening? What happens is, we are betraying our own formula. Remember, our formula is calibrated for centered values of weight. If you forget about this and paste the raw weight number there, you’d get this this sort of wrong results. So if we wish to learn height distribution at weight 50, what we have to do is simply find what centered value of weight that corresponds to raw weight of 50. The way to do is as follows. mu_at_50 &lt;- post$alpha + post$beta*(50 - mean(d2$weight)) ggplot() + geom_density(aes(x=mu_at_50), color=&quot;dodgerblue&quot;) + labs(x = &quot;mu | weight = 50&quot;) Let’s see the density in each weight. When simulating new weights we also have to provide centered version of them. Otherwise,as we saw above, what we get would be far off. There are plenty of functions that would help you gather draws for the desired parameters from the posterior. At least for the first chapters of this book, I will try to do everything manually writing base R functions. The reason for this is making sure that we understand what’s going on inside the model. What we are going to do now is, we’ll gather parameters from the posterior and simulate means and predictions manually by putting relevant those parameters from the posterior together in accordance with the formula. f_mu &lt;- function(x) post$alpha + post$beta * x weight_new &lt;- seq(25, 70) weight_new_c &lt;- weight_new - mean(weight_new) mu &lt;- sapply(weight_new_c, f_mu) %&gt;% as.data.frame() %&gt;% rename_all(function(x) weight_new_c) %&gt;% mutate(iteration = row_number()) %&gt;% gather(weight, height, -iteration) %&gt;% group_by(weight) %&gt;% mutate(hpdi_l = HDInterval::hdi(height, credMass = 0.8)[1], hpdi_h = HDInterval::hdi(height, credMass = 0.8)[2]) %&gt;% mutate(mu = mean(height)) %&gt;% ungroup() %&gt;% mutate(weight = as.integer(weight)) What we did above is writing a function which simulates mu. If we recall the formula \\[ \\mu_i = \\alpha + \\beta x_i \\] So when we put posterior \\(\\alpha\\)s and \\(\\beta\\) in this formula, we’ll get posterior \\(\\mu_i\\). The new sequence ‘weight_new_c’ becomes the X. The rest is wrangling the data. Next, we plot it p &lt;- ggplot() p1 &lt;- p + geom_point(data = mu %&gt;% filter(iteration &lt; 101), aes(weight, height), alpha = .05, color = &#39;dodgerblue&#39;) + labs(subtitle=&quot;Density at each weight&quot;) + scale_x_continuous(n.breaks = 5, breaks = c(-20, -10, 0, 10, 20), labels = c( 30,40, 45, 50, 60)) p2 &lt;- p + geom_point(data = d2, aes(weight_c, height), shape = 1, color = &#39;dodgerblue&#39;) + geom_ribbon(data = mu, aes(x = weight, ymin = hpdi_l, ymax = hpdi_h), alpha = .1) + geom_abline(data = post, aes(intercept = mean(alpha), slope = mean(beta))) + scale_x_continuous(n.breaks = 5, breaks = c(-20, -10, 0, 10, 20), labels = c( 30,40, 45, 50, 60)) + labs(subtitle=&quot;HPDI Interval = 0.95&quot;) grid.arrange(p1, p2, nrow = 1) Now we are continuing with prediction invervals. sim_ht &lt;- sapply(weight_new_c,function(x) rnorm(NROW(post), post$alpha + post$beta * x, post$sigma)) %&gt;% as.data.frame() %&gt;% rename_all(function(x) weight_new_c)%&gt;% mutate(iteration = row_number()) %&gt;% gather(weight, height, -iteration) %&gt;% group_by(weight) %&gt;% mutate(pi_l = rethinking::PI(height, prob = 0.8)[1], pi_h = rethinking::PI(height, prob = 0.8)[2]) %&gt;% ungroup() %&gt;% mutate(weight = as.integer(weight)) p2 + geom_ribbon(data = sim_ht, mapping = aes(x=weight, ymin=pi_l, ymax=pi_h), alpha = .3) + labs(subtitle = &#39;Prediction Intervals = 0.95&#39;) Yes, too much work but but this was necessary So far, we did: - blueprinting for the golem when we spend time on visualising priors - then we engineered the golem using stan according to that blueprint - lastly, we reverse-engineered the golem to access the outputs(posterior) I know there are lot’s of packages that automates each of these processes. But if you can’t do these steps without the aid of any external package, then, I am sorry to tell you that you can’t debug your golem properly. 1.2 Polynomial Stan 1.2.1 Linear d$weight_z &lt;- (d$weight - mean(d$weight)) / sd(d$weight) stan_data_polynomial_sq &lt;- list(N = NROW(d), height = d$height, weight_z = d$weight_z ) data { int&lt;lower=1&gt; N; vector[N] height; vector[N] weight_z; } parameters { real alpha; real beta_1; real&lt;lower=0, upper=50&gt; sigma; } model { vector[N] mu = alpha + beta_1 * weight_z; height ~ normal(mu, sigma); alpha ~ normal(178, 20 ); beta_1 ~lognormal( 0, 1); } fit_linear &lt;- sampling(model_linear.stan, data = stan_data_polynomial_sq, chain=2, iter=1000, cores=4) print(fit_linear) ## Inference for Stan model: 0cc64dd7e305ca8b769e2cac7faa3a75. ## 2 chains, each with iter=1000; warmup=500; thin=1; ## post-warmup draws per chain=500, total post-warmup draws=1000. ## ## mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat ## alpha 138.31 0.01 0.40 137.53 138.04 138.30 138.57 139.12 890 1 ## beta_1 25.93 0.01 0.41 25.16 25.65 25.92 26.20 26.75 849 1 ## sigma 9.39 0.01 0.29 8.83 9.18 9.39 9.60 9.96 941 1 ## lp__ -1497.84 0.05 1.19 -1500.82 -1498.39 -1497.52 -1496.97 -1496.46 607 1 ## ## Samples were drawn using NUTS(diag_e) at Thu Jul 15 23:33:23 2021. ## For each parameter, n_eff is a crude measure of effective sample size, ## and Rhat is the potential scale reduction factor on split chains (at ## convergence, Rhat=1). post &lt;- as.data.frame(fit_linear) weight_new_z &lt;- seq(-2.2, 2, length.out = 30) sim_mu_linear &lt;- function(x) post$alpha + post$beta_1 * x sim_prediction_linear &lt;- function(x) rnorm(NROW(post), mean = sim_mu_linear(x), sd = post$sigma) simulated_mu_linear &lt;- sapply(weight_new_z, sim_mu_linear)%&gt;% as.data.frame() %&gt;% rename_all(function(x) weight_new_z) %&gt;% mutate(Iter = row_number()) %&gt;% gather(weight_new_z, height, -Iter) %&gt;% group_by(weight_new_z) %&gt;% mutate( hpdi_low = HDInterval::hdi(height, credMass = 0.8)[1], hpdi_high = HDInterval::hdi(height, credMass = 0.8)[2], mu = mean(height) ) %&gt;% ungroup %&gt;% mutate(weight_new_z = as.numeric(weight_new_z)) ######### simulated_predictions_linear &lt;- sapply(weight_new_z, sim_prediction_linear)%&gt;% as.data.frame() %&gt;% rename_all(function(x) weight_new_z) %&gt;% mutate(Iter = row_number()) %&gt;% gather(weight_new_z, height, -Iter) %&gt;% group_by(weight_new_z) %&gt;% mutate( pi_low = rethinking::PI(height, prob=0.8)[1], pi_high = rethinking::PI(height, prob=0.8)[2], mu = mean(height) ) %&gt;% ungroup()%&gt;% mutate(weight_new_z = as.numeric(weight_new_z)) p_linear &lt;- ggplot() + geom_point(data = d, aes(weight_z, height), shape = 1, color = &#39;dodgerblue&#39;) + geom_ribbon(data = simulated_predictions_linear, aes(x = weight_new_z, ymin = pi_low, ymax = pi_high), alpha = .1) + geom_line(data = simulated_mu_linear, aes(weight_new_z, mu)) + labs(x = &#39;weight&#39;) 1.2.2 Quadratic data { int&lt;lower=1&gt; N; vector[N] height; vector[N] weight_z; } parameters { real alpha; real beta_1; real beta_2; real&lt;lower=0, upper=50&gt; sigma; } model { vector[N] mu = alpha + beta_1 * weight_z + beta_2 * (weight_z .* weight_z); height ~ normal(mu, sigma); alpha ~ normal(178, 20 ); beta_1 ~ lognormal( 0, 1); beta_2 ~ normal(0, 1); } fit_polynomial_quad &lt;- sampling(model_polynomial_quad.stan, data = stan_data_polynomial_sq, chain=2, iter=1000, cores=4) print(fit_polynomial_quad) ## Inference for Stan model: 6cda0f35505848d6f9ad542ef26c8869. ## 2 chains, each with iter=1000; warmup=500; thin=1; ## post-warmup draws per chain=500, total post-warmup draws=1000. ## ## mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat ## alpha 146.04 0.02 0.38 145.29 145.79 146.05 146.29 146.76 532 1 ## beta_1 21.73 0.01 0.30 21.12 21.53 21.73 21.93 22.33 733 1 ## beta_2 -7.79 0.01 0.28 -8.32 -7.99 -7.80 -7.62 -7.23 568 1 ## sigma 5.80 0.01 0.18 5.47 5.67 5.80 5.91 6.18 898 1 ## lp__ -1265.84 0.06 1.40 -1269.05 -1266.62 -1265.55 -1264.78 -1264.00 562 1 ## ## Samples were drawn using NUTS(diag_e) at Thu Jul 15 23:33:49 2021. ## For each parameter, n_eff is a crude measure of effective sample size, ## and Rhat is the potential scale reduction factor on split chains (at ## convergence, Rhat=1). post &lt;- as.data.frame(fit_polynomial_quad) weight_new_z &lt;- seq(-2.2, 2, length.out = 30) sim_mu_quad &lt;- function(x) post$alpha + post$beta_1 * x + post$beta_2 * (x^2) sim_prediction_quad &lt;- function(x) rnorm(NROW(post), mean = post$alpha + post$beta_1 * x + post$beta_2 * (x^2), sd = post$sigma) simulated_mu &lt;- sapply(weight_new_z, sim_mu_quad)%&gt;% as.data.frame() %&gt;% rename_all(function(x) weight_new_z) %&gt;% mutate(Iter = row_number()) %&gt;% gather(weight_new_z, height, -Iter) %&gt;% group_by(weight_new_z) %&gt;% mutate( hpdi_low = HDInterval::hdi(height, credMass = 0.8)[1], hpdi_high = HDInterval::hdi(height, credMass = 0.8)[2], mu = mean(height) ) %&gt;% ungroup %&gt;% mutate(weight_new_z = as.numeric(weight_new_z)) ######### simulated_predictions &lt;- sapply(weight_new_z, sim_prediction_quad)%&gt;% as.data.frame() %&gt;% rename_all(function(x) weight_new_z) %&gt;% mutate(Iter = row_number()) %&gt;% gather(weight_new_z, height, -Iter) %&gt;% group_by(weight_new_z) %&gt;% mutate( pi_low = rethinking::PI(height, prob=0.8)[1], pi_high = rethinking::PI(height, prob=0.8)[2], mu = mean(height) ) %&gt;% ungroup()%&gt;% mutate(weight_new_z = as.numeric(weight_new_z)) p_quad &lt;- ggplot() + geom_point(data = d, aes(weight_z, height), shape = 1, color = &#39;dodgerblue&#39;) + geom_ribbon(data = simulated_predictions, aes(x = weight_new_z, ymin = pi_low, ymax = pi_high), alpha = .1) + geom_line(data = simulated_mu, aes(weight_new_z, mu)) + labs(x = &#39;weight&#39;) 1.2.3 Cubic Now let’s fit a cubic model data { int&lt;lower=1&gt; N; vector[N] height; vector[N] weight_z; } parameters { real alpha; real beta_1; real beta_2; real beta_3; real&lt;lower=0, upper=50&gt; sigma; } model { vector[N] mu = alpha + beta_1 * weight_z + beta_2 * (weight_z .* weight_z) + beta_3 * (weight_z .* weight_z .* weight_z); height ~ normal(mu, sigma); alpha ~ normal(178, 20 ); beta_1 ~ lognormal( 0, 1); beta_2 ~ normal(0, 1); beta_3 ~ normal(0, 1); } fit_polynomial_cubic &lt;- sampling(model_polynomial_cubic.stan, data = stan_data_polynomial_sq, chain=2, iter=1000, cores=4) print(fit_polynomial_cubic) ## Inference for Stan model: 65abd3a39add4d74f190faa19f781c83. ## 2 chains, each with iter=1000; warmup=500; thin=1; ## post-warmup draws per chain=500, total post-warmup draws=1000. ## ## mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat ## alpha 146.38 0.01 0.32 145.70 146.17 146.38 146.59 147.00 554 1 ## beta_1 15.22 0.02 0.50 14.29 14.88 15.21 15.53 16.26 472 1 ## beta_2 -6.18 0.01 0.28 -6.69 -6.37 -6.20 -5.99 -5.62 476 1 ## beta_3 3.59 0.01 0.25 3.11 3.42 3.59 3.75 4.07 464 1 ## sigma 4.87 0.01 0.15 4.58 4.76 4.86 4.96 5.18 511 1 ## lp__ -1163.21 0.09 1.68 -1167.48 -1164.00 -1162.91 -1161.96 -1160.99 363 1 ## ## Samples were drawn using NUTS(diag_e) at Thu Jul 15 23:34:15 2021. ## For each parameter, n_eff is a crude measure of effective sample size, ## and Rhat is the potential scale reduction factor on split chains (at ## convergence, Rhat=1). post &lt;- as.data.frame(fit_polynomial_cubic) weight_new_z &lt;- seq(-2.2, 2, length.out = 30) sim_mu_cubic &lt;- function(x) post$alpha + post$beta_1 * x + post$beta_2 * (x^2) + post$beta_3 * (x^3) sim_prediction_cubic &lt;- function(x) rnorm(NROW(post), mean = sim_mu_cubic(x), sd = post$sigma) simulated_mu_cubic &lt;- sapply(weight_new_z, sim_mu_cubic)%&gt;% as.data.frame() %&gt;% rename_all(function(x) weight_new_z) %&gt;% mutate(Iter = row_number()) %&gt;% gather(weight_new_z, height, -Iter) %&gt;% group_by(weight_new_z) %&gt;% mutate( hpdi_low = HDInterval::hdi(height, credMass = 0.8)[1], hpdi_high = HDInterval::hdi(height, credMass = 0.8)[2], mu = mean(height) ) %&gt;% ungroup %&gt;% mutate(weight_new_z = as.numeric(weight_new_z)) ######### simulated_predictions_cubic &lt;- sapply(weight_new_z, sim_prediction_cubic)%&gt;% as.data.frame() %&gt;% rename_all(function(x) weight_new_z) %&gt;% mutate(Iter = row_number()) %&gt;% gather(weight_new_z, height, -Iter) %&gt;% group_by(weight_new_z) %&gt;% mutate( pi_low = rethinking::PI(height, prob=0.8)[1], pi_high = rethinking::PI(height, prob=0.8)[2], mu = mean(height) ) %&gt;% ungroup()%&gt;% mutate(weight_new_z = as.numeric(weight_new_z)) p_cubic &lt;- ggplot() + geom_point(data = d, aes(weight_z, height), shape = 1, color = &#39;dodgerblue&#39;) + geom_ribbon(data = simulated_predictions_cubic, aes(x = weight_new_z, ymin = pi_low, ymax = pi_high), alpha = .1) + geom_line(data = simulated_mu_cubic, aes(weight_new_z, mu)) + labs(x = &#39;weight&#39;) grid.arrange(p_linear,p_quad, p_cubic, nrow = 1) 1.2.4 B-Splines \\[T_i \\sim \\mathrm{Normal}(\\mu_i, \\sigma) \\\\ \\ \\ \\ \\mu_i = \\alpha + \\sum_{k=1}^{K} W_{k} B_{k,i} \\\\ \\alpha \\sim \\mathrm{Normal(6,10)} \\\\ W_j \\sim \\mathrm{Normal(0, 1)} \\\\ \\sigma \\sim \\mathrm{Exponential(1)}\\] Seems daunting. How to model this? First, let’s prepare the data. data(cherry_blossoms) d &lt;- cherry_blossoms precis precis(d) ## mean sd 5.5% 94.5% histogram ## year 1408.000000 350.8845964 867.77000 1948.23000 ▇▇▇▇▇▇▇▇▇▇▇▇▁ ## doy 104.540508 6.4070362 94.43000 115.00000 ▁▂▅▇▇▃▁▁ ## temp 6.141886 0.6636479 5.15000 7.29470 ▁▃▅▇▃▂▁▁ ## temp_upper 7.185151 0.9929206 5.89765 8.90235 ▁▂▅▇▇▅▂▂▁▁▁▁▁▁▁ ## temp_lower 5.098941 0.8503496 3.78765 6.37000 ▁▁▁▁▁▁▁▃▅▇▃▂▁▁▁ We’ll use the complete cases. Not missing ones d2 &lt;- d[ complete.cases(d$temp) , ] Here comes the magic part # num knots num_knots &lt;- 15 # list of knots knot_list &lt;- quantile( d2$year , probs=seq(0,1,length.out=num_knots) ) # basis function of 3rd degree cubic spline B &lt;- bs(d2$year, knots=knot_list[-c(1,num_knots)] , degree=3 , intercept=TRUE ) plot(NULL, xlim = range(d2$year), ylim=c(0, 1), xlab=&quot;year&quot; , ylab=&quot;basis value&quot;) for (i in 1:NCOL(B)) lines(d2$year, B[,i]) #### When you don’t know how to proceed: Learning from BRMS Well, to be honest as a beginner I don’t know how to model this using stan. What can we do when such thing happens? Well, stan has a very dedicated [community][https://discourse.mc-stan.org] as far as I can see. I have never posted there, but I am regularly reading and as it seems, the people are really willing to help you with anything there. Let’s keep this in mind. However, I think this should be the last resort. Why? Because people in the stan forums are doing this voluntarily. It’s not their job. If we go there and post a question which already has a solution in the internet, then, in the long term this will hurt the forum. So, let’s save this option for the rainy days and try to solve it on our own. What I am proposing you here is to make use of a legendary package BRMS. As you may know BRMS allows you to model using LME4ish syntax (patsy formulas they call it I guess). While you are using that special and easy syntax, BRMS on the fly creates stan code for you internally. Yes basically it’s raw stan deep inside. It’s both cursing and a blessing. It may save you enormous amount of time by allowing you to use it’s own easy syntax. But keep in mind that this only holds true when you know what you are doing. Otherwise, it can give you the false sense of expertise. Please go ahead and play with it. You can even fit a gaussian process model as simple as this: &#39;&#39;&#39; y ~ gp(X, params=Placeholder_arbitrary_some_number_that_you_dont_understand) &#39;&#39;&#39; Yes, you did it! But do you really understand it? If someone asks you some questions about your model, what would be your answer? Can you explain it to someone who has no statistical literacy? If no, let’s stick with our approach here. What we are going to do is making use of BRMS’ stan code creating functionality. All you have to do is giving her a formula and data. You don’t even have to fit it. However, we are going to fit it here just to check whether it matches McElreath’s solution. I copy paste the code from Solomon Kurz’s edition where he walked through each example in the book using brms. work! Please check [that] too. (But make sure that you come back here. We are not done yet). I made some changes because his code doesn’t match the book version that I have. Great d3 &lt;- d2 %&gt;% mutate(B = B) b4.8 &lt;- brm(data = d3, family = gaussian, temp ~ 1 + B, prior = c(prior(normal(6, 10), class = Intercept), prior(normal(0, 1), class = b), prior(exponential(1), class = sigma)), iter = 2000, warmup = 1000, chains = 4, cores = 4, seed = 4) ## Warning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable. ## Running the chains for more iterations may help. See ## http://mc-stan.org/misc/warnings.html#bulk-ess We fit the model above. let’s see it matches the book. f &lt;- fitted(b4.8) f %&gt;% data.frame() %&gt;% bind_cols(d2) %&gt;% ggplot(aes(x = year, y = temp, ymin = Q2.5, ymax = Q97.5)) + geom_vline(xintercept = knot_list, color = &quot;white&quot;, alpha = 0.5) + geom_hline(yintercept = fixef(b4.8)[1, 1], color = &quot;white&quot;, linetype = 2) + geom_point(color = &quot;dodgerblue&quot;, alpha = 0.5) + geom_ribbon(fill = &quot;black&quot;, alpha = 0.6) + labs(x = &quot;year&quot;, y = &quot;March Temperature&quot;) Yupp! That’s the plot I see in the book. Yes, all credit goes to BRMS. We did nothing. Our task begins here. Let’s see the Stan code that the BRMS created for us. stancode(b4.8) ## // generated with brms 2.15.0 ## functions { ## } ## data { ## int&lt;lower=1&gt; N; // total number of observations ## vector[N] Y; // response variable ## int&lt;lower=1&gt; K; // number of population-level effects ## matrix[N, K] X; // population-level design matrix ## int prior_only; // should the likelihood be ignored? ## } ## transformed data { ## int Kc = K - 1; ## matrix[N, Kc] Xc; // centered version of X without an intercept ## vector[Kc] means_X; // column means of X before centering ## for (i in 2:K) { ## means_X[i - 1] = mean(X[, i]); ## Xc[, i - 1] = X[, i] - means_X[i - 1]; ## } ## } ## parameters { ## vector[Kc] b; // population-level effects ## real Intercept; // temporary intercept for centered predictors ## real&lt;lower=0&gt; sigma; // residual SD ## } ## transformed parameters { ## } ## model { ## // likelihood including constants ## if (!prior_only) { ## target += normal_id_glm_lpdf(Y | Xc, Intercept, b, sigma); ## } ## // priors including constants ## target += normal_lpdf(b | 0, 1); ## target += normal_lpdf(Intercept | 6, 10); ## target += exponential_lpdf(sigma | 1); ## } ## generated quantities { ## // actual population-level intercept ## real b_Intercept = Intercept - dot_product(means_X, b); ## } Hmm, that looks really complicated. Actually it’s not. Let’s break it down. &#39;&#39;&#39; data { int&lt;lower=1&gt; N; // total number of observations vector[N] Y; // response variable int&lt;lower=1&gt; K; // number of population-level effects matrix[N, K] X; // population-level design matrix int prior_only; // should the likelihood be ignored? } &#39;&#39;&#39; Paul Bürkner -the creater of the package- already put there explanations. Y is our temperature variable.K is number of knots in our case. X is the design matrix with N number of rows and K(knots) number of columns. The last part is something we don’t have to pay attention in this example. You can delete it. &#39;&#39;&#39; } transformed data { int Kc = K - 1; matrix[N, Kc] Xc; // centered version of X without an intercept vector[Kc] means_X; // column means of X before centering for (i in 2:K) { means_X[i - 1] = mean(X[, i]); Xc[, i - 1] = X[, i] - means_X[i - 1]; } &#39;&#39;&#39; Now move on with parameters block. Pay attention to vector b and real intercept part. This will be useful later. &#39;&#39;&#39; parameters { vector[Kc] b; // population-level effects real Intercept; // temporary intercept for centered predictors real&lt;lower=0&gt; sigma; // residual SD } &#39;&#39;&#39; As the name hints, Transformed parameters is the block where you make transformations on the data inside the stan model. Basically BRMS is centering it. We don’t have to do this. So don’t let it confuse or scare you. &#39;&#39;&#39; model { // likelihood including constants if (!prior_only) { target += normal_id_glm_lpdf(Y | Xc, Intercept, b, sigma); } // priors including constants target += normal_lpdf(b | 0, 1); target += normal_lpdf(Intercept | 6, 10); target += exponential_lpdf(sigma | 1); } &#39;&#39;&#39; So what does the first line imply? As far as I can see it from here, it says, in the cases where the model is not prior predictive simulations (the int prior only part in the data block), then use this likelihood. Otherwise, ignore the likelihood. Since we are interested in the likelihood, lets see how brms constructs it for splines. target += normal_id_glm_lpdf(Y | Xc, Intercept, b, sigma); is the key element here. The rest is given us by McElreath. When we check stan user’s guide, there it explains what this one does as: real normal_id_glm_lpdf(vector y | matrix x, real alpha, vector beta, real sigma) The log normal probability density of y given location alpha+x*beta and scale sigma, where a constant &gt;intercept alpha and sigma is used for all observations. The number of rows of the independent &gt;variable matrix x needs to match the length of the dependent variable vector y and the number of &gt;columns of x needs to match the length of the weight vector beta So now we know what it does internally and we can use it in our own version. But of course we have to create data for stan. spline_data &lt;- list(N =NROW(d3), t = d3$temp, knots = NCOL(d3$B), X = d3$B) data { int&lt;lower=1&gt; N; vector[N] t; int&lt;lower=1&gt; knots; matrix[N, knots] X; } parameters { vector[knots] b; real alpha; real&lt;lower=0&gt; sigma; } transformed parameters{ vector[N] mu = alpha + X * b; } model { t ~ normal(mu, sigma); b ~ normal(0, 1); alpha ~ normal(6, 10); sigma ~ exponential(1); } fit_spline &lt;- sampling(spline_model.stan, spline_data, iter=2000, chain=4, cores=4) ## Warning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable. ## Running the chains for more iterations may help. See ## http://mc-stan.org/misc/warnings.html#bulk-ess plot_spline &lt;- fit_spline%&gt;%gather_draws(mu[i]) %&gt;% mean_qi() %&gt;% rename(yhat = .value) plot_spline$year &lt;- d3$year plot_spline$temp &lt;- d3$temp ggplot(data= plot_spline) + geom_point(aes(x=year, y=temp), color=&quot;dodgerblue&quot;) + geom_ribbon(aes(x=year, y=yhat, ymin=.lower, ymax=.upper)) "],["the-pool-of-tears.html", "Chapter 2 The pool of tears", " Chapter 2 The pool of tears "],["a-caucus-race-and-a-long-tale.html", "Chapter 3 A caucus-race and a long tale", " Chapter 3 A caucus-race and a long tale "]]
