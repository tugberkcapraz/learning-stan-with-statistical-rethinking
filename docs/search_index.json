[["index.html", "Learning Stan with Statistical Retinking Chapter 1 Geocentric Models 1.1 Gaussian Model of Height 1.2 Linear Prediction 1.3 Curves From Lines", " Learning Stan with Statistical Retinking Kerem Tugberk Capraz 2021-07-17 Chapter 1 Geocentric Models library(rethinking) library(dplyr) library(tidyr) library(rstan) library(ggplot2) library(ggthemes) library(gridExtra) library(grid) library(tidybayes) library(tidyverse) library(bayesplot) library(splines) library(purrr) library(stringr) library(brms) data(Howell1) d &lt;- Howell1 d2 &lt;- d[ d$age &gt;= 18 , ] 1.1 Gaussian Model of Height McElreath’s linear model is as follows: \\[h_i \\sim \\textrm{Normal} (\\mu, \\sigma)\\\\ \\ \\ \\ \\ \\ \\ \\mu \\sim \\textrm{Normal(178, 20)}\\\\ \\ \\ \\sigma \\sim \\textrm{Uniform(0,50)}\\] Before doing anything let’s visually understand what \\[\\mu \\sim \\textrm{Normal(178, 20)}\\] means curve(dnorm(x, 178, 20), from = 100, to=250) This is how a normal distribution with mean of 178 and standard deviation of 20 looks like. So we started doing something already. Now let’s visualise \\[\\sigma \\sim \\textrm{Uniform(0, 50)}\\] curve(dunif(x, 0, 50), from=-10, to=60) Everything looks cool so far. Now it’s time to simulate fake height numbers implied by these priors. What we are going to do is using ‘rnorm’ and ‘runif’ functions with the numbers given us by McElreath. prior_mu and prior_sigma are the random numbers generated for mu and sigma when we plug the numbers. prior_height_sim is again using rnorm, but this time rather than setting an arbitrary number for mean and sd parameters inside the rnorm, we are plugging the derived prior_mu and prior_sigma as mean and sd respectively. then we plot it prior_mu &lt;- rnorm(1e4, 178, 20) prior_sigma &lt;- runif(1e4, 0, 50) prior_height_sim &lt;- rnorm(1e4, prior_mu, prior_sigma) dens(prior_height_sim) As you can see the resulting distribution of height is plausible. In order to see what happens under different prior description of the height, we this time tweak the standard deviation of prior mu \\[\\mu \\sim \\textrm{Normal(178, 100)}\\] Let’s see what happens prior_mu &lt;- rnorm(1e4, 178, 100) prior_height_sim &lt;- rnorm(1e4, prior_mu, prior_sigma) dens(prior_height_sim) Oh my god! This is horrible. Uncertainty is good, however this doesn’t mean that we have to introduce this sort of ridiculous uncertainty into our models. We all know that there are no people around 400 cm tall. Moreover, this distribution also implies that some people have negative heights! Bad prior. Don’t use it. Now it’s time to use magnificent Stan language for the first time. Fasten your seatbelts. During the course of these notebooks I will write inline stan codes. I normally don’t do it this way. When working with stan, if you separate your scripts and stan files, then, someone else using pystan juliastan etc can easily plug and play with your models in their environments with minimum effort. Plus, it’s also more organized when your stan code is outside of your script. 1.1.1 Using Stan for the First Time When using stan, at first it may seem daunting that you have to do lot of things manually. I understand and to a degree aggree that this is little bit uncomfortable. However, if you really wish to learn what sort of operations that are taken care of when you are using your ordinary statistics package, then, stan is perhaps the best way. Furthermore, even if you have no appetite for learning what’s happening under the hood when you are fitting models, it’s still essential that you have an idea about what goes beneath the surface. Every statistical modelling package or program make decisions on behalf of you. You may call them assumptions or whatever it pleases you. When you know about them, you can start modifying them for your purposes. Stan accepts the data in list format. Whatever you are going to use inside your models must be represented here. stan_data_4_1 &lt;- list(N = NROW(d2), height = d2$height) So, we have only two elements in this list. What are they? N is the number of observations. We are telling stan program how many observations that it should expect.The height is the vector containing height data. There two important points here 1) Naming is up to you. You can call it N or whatever you think it fits. However, once you name it here, you have to stick with that name inside the stan program. Don’t make changes on the fly. And pick names that you can easily remember. This may not seem to be a big issue to you right now. But when the models get complex, then your naming convention will help you. Lets call it clear names principle 2) As you can see, N is just a number. Why didn’t I just pass there the number? It’s related to strategic thinking. In real world applications, unlike these toy examples, the statistical analyses are so rarely linear processes. It doesn’t work in a way that you advance step by step and never return to previous steps. Rather, you try something out. Then you find some discrepancy and you go back to square number one and try different approach (further cleaning, transformation etc.) with your data. So, if you put a constant number there directly, then each time you modified your data you have to make sure that N is still up to date. ‘NROW(d2)’ makes this clear for you. We can call this one don’t hard code principle //What this all means is: //Dear golem, data{ int&lt;lower=1&gt; N; // N is number of observations. I gave you this in the data. vector[N] height; // Height is a vector containing N observations. This is also //in the data } parameters{ real mu; // mu real&lt;lower=0, upper=50&gt; sigma; //sigma // I&#39;ll give details of them in the next block. Just recognize them for now. } model{ height ~ normal(mu, sigma); //height is normally distributed with mu and sigma mu ~ normal(178, 20); //mu is also normally distributed and &quot;I think&quot; mean is //around 178 and since &quot;I think&quot; 138 and 218 are kind of good candidates for //being +-2 standard deviations boundary. sigma ~ uniform(0,50); //sigma is uniformly distributed and can take values between // 0 and 50 } // best regards So, in the comments part I also tried to outline what’s happening inside the stan model by keeping up with McElreath’s Golem analogy. Let’s move on with fitting it. fit_4_1 &lt;- sampling(model_4_1.stan, stan_data_4_1, iter=1000, chains=2, cores=4) print(fit_4_1) ## Inference for Stan model: 027d8e5b047e6b17c3edb7d22b5b286a. ## 2 chains, each with iter=1000; warmup=500; thin=1; ## post-warmup draws per chain=500, total post-warmup draws=1000. ## ## mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat ## mu 154.59 0.01 0.41 153.81 154.31 154.59 154.87 155.39 828 1.00 ## sigma 7.76 0.01 0.31 7.19 7.55 7.75 7.95 8.40 707 1.00 ## lp__ -895.78 0.05 1.08 -898.45 -896.14 -895.45 -895.05 -894.77 497 1.01 ## ## Samples were drawn using NUTS(diag_e) at Sat Jul 17 13:46:38 2021. ## For each parameter, n_eff is a crude measure of effective sample size, ## and Rhat is the potential scale reduction factor on split chains (at ## convergence, Rhat=1). So it was your first model using stan. Congrats! 1.2 Linear Prediction Our next target, following the book is making use of weight variable to predict heights. Before doing so let’s start with plotting them together. plot( d2$height ~ d2$weight ) There’s an obvious relationship among those 2. Look how height gets bigger as weight gets bigger. Let’s write down the model: \\[h_i \\sim \\textrm{Normal}(\\mu, \\sigma) \\\\ \\ \\ \\mu_i = \\alpha + \\beta_i(x_i - \\bar{x})\\\\ \\ \\ \\ \\ \\ \\alpha \\sim \\textrm{Normal}(178, 20) \\\\ \\ \\ \\beta \\sim \\textrm{Normal}(0, 10)\\\\ \\ \\ \\ \\sigma \\sim \\textrm{Uniform}(0,50)\\] Notice two things. There’s the new parameter \\(\\beta\\).And this is multiplied by \\(x_i -\\bar{x}\\). The latter is called centering. So let’s do that. d2$weight_c &lt;- d2$weight - mean(d2$weight) And prepare the stan data. stan_data_4_3 &lt;- list(N = NROW(d2), height = d2$height, weight_c = d2$weight_c) But maybe we are going too fast. Let’s talk about prior that we set for \\(\\beta\\). Why did we set this? More importantly, do we know what does that imply? \\(\\beta\\) is telling us about the effect. Is Normal(0,10) a good one? One way to know. Let’s plot it N &lt;- 100 # number of lines a &lt;- rnorm(N, 178, 20) # alpha b &lt;- rnorm(N, 0, 10) # beta #plot them plot(NULL, xlim=range(d2$weight), ylim = c(-100, 400), xlab = &quot;weight&quot;, ylab = &quot;height&quot;) abline( h=0 , lty=2 ) # Embryo abline( h=272 , lty=1 , lwd=0.5 ) # World&#39;s tallest person mtext( &quot;b ~ dnorm(0,10)&quot; ) xbar &lt;- mean(d2$weight) for (i in 1:N ) curve(a[i] + b[i]*(x-xbar) , from = min(d2$weight), to=d2$height, add = TRUE, col = col.alpha(&quot;black&quot;, 0.2)) This prior implies that there must be some people with negative weights. Also, from it’s standpoint, 30kg to 400cm decreases to -100cm when the weight gets 60. Not plausible at all. Feel free to try different priors. I’ll shoot one N &lt;- 100 # number of lines a &lt;- rnorm(N, 178, 20) # alpha b &lt;- rnorm(N, 0, 1.5) # beta #plot them plot(NULL, xlim=range(d2$weight), ylim = c(-100, 400), xlab = &quot;weight&quot;, ylab = &quot;height&quot;) abline( h=0 , lty=2 ) # Embryo abline( h=272 , lty=1 , lwd=0.5 ) # World&#39;s tallest person mtext( &quot;b ~ dnorm(0,1.5)&quot; ) xbar &lt;- mean(d2$weight) for (i in 1:N ) curve(a[i] + b[i]*(x-xbar) , from = min(d2$weight), to=d2$height, add = TRUE, col = col.alpha(&quot;black&quot;, 0.2)) Not great, not terrible. Let’s continue with McElreath’s prior. b &lt;- rlnorm(N, 0, 1) # plot the chunk above plot(NULL, xlim=range(d2$weight) , ylim=c(-100,400) , xlab=&quot;weight&quot; , ylab=&quot;height&quot; ) abline( h=0 , lty=2 ) abline( h=272 , lty=1 , lwd=0.5 ) mtext( &quot;b ~ lognorm(0,1)&quot; ) xbar &lt;- mean(d2$weight) for ( i in 1:N ) curve( a[i] + b[i]*(x - xbar) , from=min(d2$weight) , to=max(d2$weight) , add=TRUE , col=col.alpha(&quot;black&quot;,0.2) ) data { int&lt;lower=1&gt; N; vector[N] height; vector[N] weight_c; } parameters { real alpha; real beta; real&lt;lower=0,upper=50&gt; sigma; } model { vector[N] mu = alpha + beta * weight_c; height~ normal(mu, sigma); alpha ~ normal(178, 20); beta ~ lognormal(0, 1); sigma ~ uniform(0,50); } # fit fit_4_3 &lt;- sampling(model_4_3.stan, data = stan_data_4_3, iter = 1000, chains = 2, cores = 2) print(fit_4_3, probs = c(0.1, 0.5, 0.9)) ## Inference for Stan model: 1b47a5d1ac27ee76501545aa74cbaa76. ## 2 chains, each with iter=1000; warmup=500; thin=1; ## post-warmup draws per chain=500, total post-warmup draws=1000. ## ## mean se_mean sd 10% 50% 90% n_eff Rhat ## alpha 154.60 0.01 0.27 154.24 154.60 154.95 883 1 ## beta 0.90 0.00 0.04 0.85 0.90 0.96 1023 1 ## sigma 5.11 0.01 0.19 4.86 5.10 5.37 770 1 ## lp__ -748.09 0.06 1.25 -749.90 -747.74 -746.84 485 1 ## ## Samples were drawn using NUTS(diag_e) at Sat Jul 17 13:46:44 2021. ## For each parameter, n_eff is a crude measure of effective sample size, ## and Rhat is the potential scale reduction factor on split chains (at ## convergence, Rhat=1). Plotting the posterior against data post &lt;- as.data.frame(fit_4_3) p &lt;- ggplot() + lims(y = c(100, 200)) p1 &lt;- p + geom_point(data = d2, aes(weight_c, height), shape = 1, color = &#39;dodgerblue&#39;) + geom_abline(intercept = mean(post$alpha), slope = mean(post$beta)) + scale_x_continuous(n.breaks = 3, breaks = c(-10, 0, 10), labels = c(30, 45, 55)) p1 Mean at 50 mu_at_50 &lt;- post$alpha + post$beta*50 ggplot() + geom_density(aes(x=mu_at_50), color=&quot;dodgerblue&quot; ) + labs(x = &quot;mu | weight = 50&quot;) Wait a minute it’s not possible! What’s happening? What happens is, we are betraying our own formula. Remember, our formula is calibrated for centered values of weight. If you forget about this and paste the raw weight number there, you’d get this this sort of wrong results. So if we wish to learn height distribution at weight 50, what we have to do is simply find what centered value of weight that corresponds to raw weight of 50. The way to do is as follows. mu_at_50 &lt;- post$alpha + post$beta*(50 - mean(d2$weight)) ggplot() + geom_density(aes(x=mu_at_50), color=&quot;dodgerblue&quot;) + labs(x = &quot;mu | weight = 50&quot;) Let’s see the density in each weight. When simulating new weights we also have to provide centered version of them. Otherwise,as we saw above, what we get would be far off. There are plenty of functions that would help you gather draws for the desired parameters from the posterior. At least for the first chapters of this book, I will try to do everything manually writing base R functions. The reason for this is making sure that we understand what’s going on inside the model. What we are going to do now is, we’ll gather parameters from the posterior and simulate means and predictions manually by putting relevant those parameters from the posterior together in accordance with the formula. f_mu &lt;- function(x) post$alpha + post$beta * x weight_new &lt;- seq(25, 70) weight_new_c &lt;- weight_new - mean(weight_new) mu &lt;- sapply(weight_new_c, f_mu) %&gt;% as.data.frame() %&gt;% rename_all(function(x) weight_new_c) %&gt;% mutate(iteration = row_number()) %&gt;% gather(weight, height, -iteration) %&gt;% group_by(weight) %&gt;% mutate(hpdi_l = HDInterval::hdi(height, credMass = 0.8)[1], hpdi_h = HDInterval::hdi(height, credMass = 0.8)[2]) %&gt;% mutate(mu = mean(height)) %&gt;% ungroup() %&gt;% mutate(weight = as.integer(weight)) What we did above is writing a function which simulates mu. If we recall the formula \\[ \\mu_i = \\alpha + \\beta x_i \\] So when we put posterior \\(\\alpha\\)s and \\(\\beta\\) in this formula, we’ll get posterior \\(\\mu_i\\). The new sequence ‘weight_new_c’ becomes the X. The rest is wrangling the data. Next, we plot it p &lt;- ggplot() p1 &lt;- p + geom_point(data = mu %&gt;% filter(iteration &lt; 101), aes(weight, height), alpha = .05, color = &#39;dodgerblue&#39;) + labs(subtitle=&quot;Density at each weight&quot;) + scale_x_continuous(n.breaks = 5, breaks = c(-20, -10, 0, 10, 20), labels = c( 30,40, 45, 50, 60)) p2 &lt;- p + geom_point(data = d2, aes(weight_c, height), shape = 1, color = &#39;dodgerblue&#39;) + geom_ribbon(data = mu, aes(x = weight, ymin = hpdi_l, ymax = hpdi_h), alpha = .1) + geom_abline(data = post, aes(intercept = mean(alpha), slope = mean(beta))) + scale_x_continuous(n.breaks = 5, breaks = c(-20, -10, 0, 10, 20), labels = c( 30,40, 45, 50, 60)) + labs(subtitle=&quot;HPDI Interval = 0.95&quot;) grid.arrange(p1, p2, nrow = 1) Now we are continuing with prediction invervals. sim_ht &lt;- sapply(weight_new_c,function(x) rnorm(NROW(post), post$alpha + post$beta * x, post$sigma)) %&gt;% as.data.frame() %&gt;% rename_all(function(x) weight_new_c)%&gt;% mutate(iteration = row_number()) %&gt;% gather(weight, height, -iteration) %&gt;% group_by(weight) %&gt;% mutate(pi_l = rethinking::PI(height, prob = 0.8)[1], pi_h = rethinking::PI(height, prob = 0.8)[2]) %&gt;% ungroup() %&gt;% mutate(weight = as.integer(weight)) p2 + geom_ribbon(data = sim_ht, mapping = aes(x=weight, ymin=pi_l, ymax=pi_h), alpha = .3) + labs(subtitle = &#39;Prediction Intervals = 0.95&#39;) Yes, too much work but but this was necessary So far, we did: - blueprinting for the golem when we spend time on visualising priors - then we engineered the golem using stan according to that blueprint - lastly, we reverse-engineered the golem to access the outputs(posterior) I know there are lot’s of packages that automates each of these processes. But if you can’t do these steps without the aid of any external package, then, I am sorry to tell you that you can’t debug your golem properly. 1.3 Curves From Lines In this part we are going to build three models. First one is the linear one which we already know how to do. Second will be quadratic model. And, third will be the cubic model. For each of them, we are after the model fit, we are going to do reverse engineering for accessing the posterior distribution of the \\(\\mu\\) manually. Lastly, we are going to combine all three in a plot to show differences. 1.3.1 Linear It’s the same linear model. We are fitting it for the comparison plot. d$weight_z &lt;- (d$weight - mean(d$weight)) / sd(d$weight) stan_data_polynomial_sq &lt;- list(N = NROW(d), height = d$height, weight_z = d$weight_z ) data { int&lt;lower=1&gt; N; vector[N] height; vector[N] weight_z; } parameters { real alpha; real beta_1; real&lt;lower=0, upper=50&gt; sigma; } model { vector[N] mu = alpha + beta_1 * weight_z; height ~ normal(mu, sigma); alpha ~ normal(178, 20 ); beta_1 ~lognormal( 0, 1); } fit_linear &lt;- sampling(model_linear.stan, data = stan_data_polynomial_sq, chain=2, iter=1000, cores=4) print(fit_linear) ## Inference for Stan model: 0cc64dd7e305ca8b769e2cac7faa3a75. ## 2 chains, each with iter=1000; warmup=500; thin=1; ## post-warmup draws per chain=500, total post-warmup draws=1000. ## ## mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat ## alpha 138.27 0.01 0.40 137.50 137.98 138.26 138.54 139.00 1004 1 ## beta_1 25.94 0.01 0.39 25.16 25.69 25.95 26.18 26.77 1163 1 ## sigma 9.41 0.01 0.31 8.84 9.20 9.39 9.61 10.05 966 1 ## lp__ -1497.85 0.06 1.34 -1501.58 -1498.44 -1497.47 -1496.90 -1496.43 524 1 ## ## Samples were drawn using NUTS(diag_e) at Sat Jul 17 13:46:53 2021. ## For each parameter, n_eff is a crude measure of effective sample size, ## and Rhat is the potential scale reduction factor on split chains (at ## convergence, Rhat=1). post &lt;- as.data.frame(fit_linear) weight_new_z &lt;- seq(-2.2, 2, length.out = 30) sim_mu_linear &lt;- function(x) post$alpha + post$beta_1 * x sim_prediction_linear &lt;- function(x) rnorm(NROW(post), mean = sim_mu_linear(x), sd = post$sigma) simulated_mu_linear &lt;- sapply(weight_new_z, sim_mu_linear)%&gt;% as.data.frame() %&gt;% rename_all(function(x) weight_new_z) %&gt;% mutate(Iter = row_number()) %&gt;% gather(weight_new_z, height, -Iter) %&gt;% group_by(weight_new_z) %&gt;% mutate( hpdi_low = HDInterval::hdi(height, credMass = 0.8)[1], hpdi_high = HDInterval::hdi(height, credMass = 0.8)[2], mu = mean(height) ) %&gt;% ungroup %&gt;% mutate(weight_new_z = as.numeric(weight_new_z)) ######### simulated_predictions_linear &lt;- sapply(weight_new_z, sim_prediction_linear)%&gt;% as.data.frame() %&gt;% rename_all(function(x) weight_new_z) %&gt;% mutate(Iter = row_number()) %&gt;% gather(weight_new_z, height, -Iter) %&gt;% group_by(weight_new_z) %&gt;% mutate( pi_low = rethinking::PI(height, prob=0.8)[1], pi_high = rethinking::PI(height, prob=0.8)[2], mu = mean(height) ) %&gt;% ungroup()%&gt;% mutate(weight_new_z = as.numeric(weight_new_z)) p_linear &lt;- ggplot() + geom_point(data = d, aes(weight_z, height), shape = 1, color = &#39;dodgerblue&#39;) + geom_ribbon(data = simulated_predictions_linear, aes(x = weight_new_z, ymin = pi_low, ymax = pi_high), alpha = .1) + geom_line(data = simulated_mu_linear, aes(weight_new_z, mu)) + labs(x = &#39;weight&#39;) 1.3.2 Quadratic Now the quadratic model which is mathematically written as \\[\\ h_i \\sim \\mathrm{Normal}(\\mu_i , \\sigma ) \\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\mu_i = \\alpha + \\beta_1 X_i + \\beta_2 X^2_i \\\\ \\ \\ \\ \\ \\ \\alpha \\sim \\mathrm{Normal(178, 20)} \\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\beta_1 \\sim \\mathrm{Log-Normal(0, 1)} \\\\ \\ \\beta_2 \\sim \\mathrm{Normal(0, 1)} \\\\ \\ \\ \\ \\sigma \\sim \\mathrm{Uniform(0, 50)} \\\\\\] data { int&lt;lower=1&gt; N; vector[N] height; vector[N] weight_z; } parameters { real alpha; real beta_1; real beta_2; real&lt;lower=0, upper=50&gt; sigma; } model { vector[N] mu = alpha + beta_1 * weight_z + beta_2 * (weight_z .* weight_z); height ~ normal(mu, sigma); alpha ~ normal(178, 20 ); beta_1 ~ lognormal( 0, 1); beta_2 ~ normal(0, 1); } fit_polynomial_quad &lt;- sampling(model_polynomial_quad.stan, data = stan_data_polynomial_sq, chain=2, iter=1000, cores=4) print(fit_polynomial_quad) ## Inference for Stan model: c8283f3bc71ce1c902fd867c77383633. ## 2 chains, each with iter=1000; warmup=500; thin=1; ## post-warmup draws per chain=500, total post-warmup draws=1000. ## ## mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat ## alpha 146.05 0.02 0.37 145.36 145.79 146.01 146.29 146.79 465 1.00 ## beta_1 21.73 0.01 0.30 21.17 21.52 21.71 21.94 22.34 743 1.00 ## beta_2 -7.80 0.01 0.28 -8.34 -8.00 -7.80 -7.60 -7.28 454 1.00 ## sigma 5.80 0.01 0.19 5.43 5.67 5.79 5.92 6.16 726 1.00 ## lp__ -1265.87 0.07 1.38 -1269.32 -1266.66 -1265.55 -1264.83 -1264.07 414 1.01 ## ## Samples were drawn using NUTS(diag_e) at Sat Jul 17 13:46:59 2021. ## For each parameter, n_eff is a crude measure of effective sample size, ## and Rhat is the potential scale reduction factor on split chains (at ## convergence, Rhat=1). post &lt;- as.data.frame(fit_polynomial_quad) weight_new_z &lt;- seq(-2.2, 2, length.out = 30) sim_mu_quad &lt;- function(x) post$alpha + post$beta_1 * x + post$beta_2 * (x^2) sim_prediction_quad &lt;- function(x) rnorm(NROW(post), mean = post$alpha + post$beta_1 * x + post$beta_2 * (x^2), sd = post$sigma) simulated_mu &lt;- sapply(weight_new_z, sim_mu_quad)%&gt;% as.data.frame() %&gt;% rename_all(function(x) weight_new_z) %&gt;% mutate(Iter = row_number()) %&gt;% gather(weight_new_z, height, -Iter) %&gt;% group_by(weight_new_z) %&gt;% mutate( hpdi_low = HDInterval::hdi(height, credMass = 0.8)[1], hpdi_high = HDInterval::hdi(height, credMass = 0.8)[2], mu = mean(height) ) %&gt;% ungroup %&gt;% mutate(weight_new_z = as.numeric(weight_new_z)) ######### simulated_predictions &lt;- sapply(weight_new_z, sim_prediction_quad)%&gt;% as.data.frame() %&gt;% rename_all(function(x) weight_new_z) %&gt;% mutate(Iter = row_number()) %&gt;% gather(weight_new_z, height, -Iter) %&gt;% group_by(weight_new_z) %&gt;% mutate( pi_low = rethinking::PI(height, prob=0.8)[1], pi_high = rethinking::PI(height, prob=0.8)[2], mu = mean(height) ) %&gt;% ungroup()%&gt;% mutate(weight_new_z = as.numeric(weight_new_z)) p_quad &lt;- ggplot() + geom_point(data = d, aes(weight_z, height), shape = 1, color = &#39;dodgerblue&#39;) + geom_ribbon(data = simulated_predictions, aes(x = weight_new_z, ymin = pi_low, ymax = pi_high), alpha = .1) + geom_line(data = simulated_mu, aes(weight_new_z, mu)) + labs(x = &#39;weight&#39;) 1.3.3 Cubic Now let’s fit a cubic model Now the quadratic model which is mathematically written as \\[\\ h_i \\sim \\mathrm{Normal}(\\mu_i , \\sigma ) \\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\mu_i = \\alpha + \\beta_1 X_i + \\beta_2 X^2_i + \\beta_3 X^3_i \\\\ \\ \\ \\ \\ \\ \\alpha \\sim \\mathrm{Normal(178, 20)} \\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\beta_1 \\sim \\mathrm{Log-Normal(0, 1)} \\\\ \\ \\beta_2 \\sim \\mathrm{Normal(0, 1)} \\\\ \\ \\beta_3 \\sim \\mathrm{Normal(0, 1)} \\\\ \\ \\ \\ \\sigma \\sim \\mathrm{Uniform(0, 50)}\\] data { int&lt;lower=1&gt; N; vector[N] height; vector[N] weight_z; } parameters { real alpha; real beta_1; real beta_2; real beta_3; real&lt;lower=0, upper=50&gt; sigma; } model { vector[N] mu = alpha + beta_1 * weight_z + beta_2 * (weight_z .* weight_z) + beta_3 * (weight_z .* weight_z .* weight_z); height ~ normal(mu, sigma); alpha ~ normal(178, 20 ); beta_1 ~ lognormal( 0, 1); beta_2 ~ normal(0, 1); beta_3 ~ normal(0, 1); } fit_polynomial_cubic &lt;- sampling(model_polynomial_cubic.stan, data = stan_data_polynomial_sq, chain=2, iter=1000, cores=4) print(fit_polynomial_cubic) ## Inference for Stan model: 65abd3a39add4d74f190faa19f781c83. ## 2 chains, each with iter=1000; warmup=500; thin=1; ## post-warmup draws per chain=500, total post-warmup draws=1000. ## ## mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat ## alpha 146.40 0.01 0.32 145.77 146.17 146.39 146.61 147.02 625 1.00 ## beta_1 15.24 0.02 0.45 14.38 14.92 15.24 15.56 16.11 583 1.00 ## beta_2 -6.21 0.01 0.26 -6.70 -6.40 -6.21 -6.03 -5.73 612 1.00 ## beta_3 3.58 0.01 0.22 3.12 3.43 3.57 3.72 4.00 571 1.00 ## sigma 4.87 0.01 0.16 4.57 4.75 4.86 4.98 5.17 674 1.01 ## lp__ -1163.14 0.07 1.56 -1167.01 -1164.04 -1162.85 -1161.98 -1160.96 529 1.00 ## ## Samples were drawn using NUTS(diag_e) at Sat Jul 17 13:47:05 2021. ## For each parameter, n_eff is a crude measure of effective sample size, ## and Rhat is the potential scale reduction factor on split chains (at ## convergence, Rhat=1). post &lt;- as.data.frame(fit_polynomial_cubic) weight_new_z &lt;- seq(-2.2, 2, length.out = 30) sim_mu_cubic &lt;- function(x) post$alpha + post$beta_1 * x + post$beta_2 * (x^2) + post$beta_3 * (x^3) sim_prediction_cubic &lt;- function(x) rnorm(NROW(post), mean = sim_mu_cubic(x), sd = post$sigma) simulated_mu_cubic &lt;- sapply(weight_new_z, sim_mu_cubic)%&gt;% as.data.frame() %&gt;% rename_all(function(x) weight_new_z) %&gt;% mutate(Iter = row_number()) %&gt;% gather(weight_new_z, height, -Iter) %&gt;% group_by(weight_new_z) %&gt;% mutate( hpdi_low = HDInterval::hdi(height, credMass = 0.8)[1], hpdi_high = HDInterval::hdi(height, credMass = 0.8)[2], mu = mean(height) ) %&gt;% ungroup %&gt;% mutate(weight_new_z = as.numeric(weight_new_z)) ######### simulated_predictions_cubic &lt;- sapply(weight_new_z, sim_prediction_cubic)%&gt;% as.data.frame() %&gt;% rename_all(function(x) weight_new_z) %&gt;% mutate(Iter = row_number()) %&gt;% gather(weight_new_z, height, -Iter) %&gt;% group_by(weight_new_z) %&gt;% mutate( pi_low = rethinking::PI(height, prob=0.8)[1], pi_high = rethinking::PI(height, prob=0.8)[2], mu = mean(height) ) %&gt;% ungroup()%&gt;% mutate(weight_new_z = as.numeric(weight_new_z)) p_cubic &lt;- ggplot() + geom_point(data = d, aes(weight_z, height), shape = 1, color = &#39;dodgerblue&#39;) + geom_ribbon(data = simulated_predictions_cubic, aes(x = weight_new_z, ymin = pi_low, ymax = pi_high), alpha = .1) + geom_line(data = simulated_mu_cubic, aes(weight_new_z, mu)) + labs(x = &#39;weight&#39;) grid.arrange(p_linear,p_quad, p_cubic, nrow = 1) 1.3.4 B-Splines \\[T_i \\sim \\mathrm{Normal}(\\mu_i, \\sigma) \\\\ \\ \\ \\ \\mu_i = \\alpha + \\sum_{k=1}^{K} W_{k} B_{k,i} \\\\ \\alpha \\sim \\mathrm{Normal(6,10)} \\\\ W_j \\sim \\mathrm{Normal(0, 1)} \\\\ \\sigma \\sim \\mathrm{Exponential(1)}\\] Seems daunting. How to model this? First, let’s prepare the data. data(cherry_blossoms) d &lt;- cherry_blossoms precis precis(d) ## mean sd 5.5% 94.5% histogram ## year 1408.000000 350.8845964 867.77000 1948.23000 ▇▇▇▇▇▇▇▇▇▇▇▇▁ ## doy 104.540508 6.4070362 94.43000 115.00000 ▁▂▅▇▇▃▁▁ ## temp 6.141886 0.6636479 5.15000 7.29470 ▁▃▅▇▃▂▁▁ ## temp_upper 7.185151 0.9929206 5.89765 8.90235 ▁▂▅▇▇▅▂▂▁▁▁▁▁▁▁ ## temp_lower 5.098941 0.8503496 3.78765 6.37000 ▁▁▁▁▁▁▁▃▅▇▃▂▁▁▁ We’ll use the complete cases. Not missing ones d2 &lt;- d[ complete.cases(d$temp) , ] Here comes the magic part # num knots num_knots &lt;- 15 # list of knots knot_list &lt;- quantile( d2$year , probs=seq(0,1,length.out=num_knots) ) # basis function of 3rd degree cubic spline B &lt;- bs(d2$year, knots=knot_list[-c(1,num_knots)] , degree=3 , intercept=TRUE ) plot(NULL, xlim = range(d2$year), ylim=c(0, 1), xlab=&quot;year&quot; , ylab=&quot;basis value&quot;) for (i in 1:NCOL(B)) lines(d2$year, B[,i]) Well, to be honest as a beginner I don’t know how to model this using stan. What can we do when such thing happens? Well, stan has a very dedicated community[https://discourse.mc-stan.org] as far as I can see. I have never posted there, but I am regularly reading and as it seems, the people are really willing to help you with anything there. Let’s keep this in mind. However, I think this should be the last resort. Why? Because people in the stan forums are doing this voluntarily. It’s not their job. If we go there and post a question which already has a solution in the internet, then, in the long term this will hurt the forum. So, let’s save this option for the rainy days and try to solve it on our own. What I am proposing you here is to make use of a legendary package BRMS. As you may know BRMS allows you to model using LME4ish syntax (patsy formulas they call it I guess). While you are using that special and easy syntax, BRMS on the fly creates stan code for you internally. Yes basically it’s raw stan deep inside. It’s both cursing and a blessing. It may save you enormous amount of time by allowing you to use it’s own easy syntax. But keep in mind that this only holds true when you know what you are doing. Otherwise, it can give you the false sense of expertise. Please go ahead and play with it. You can even fit a gaussian process model as simple as this: &#39;&#39;&#39; y ~ gp(X, params=Placeholder_arbitrary_some_number_that_you_dont_understand) &#39;&#39;&#39; Yes, you did it! But do you really understand it? If someone asks you some questions about your model, what would be your answer? Can you explain it to someone who has no statistical literacy? If no, let’s stick with our approach here. What we are going to do is making use of BRMS’ stan code creating functionality. All you have to do is giving her a formula and data. You don’t even have to fit it. However, we are going to fit it here just to check whether it matches McElreath’s solution. I copy paste the code from Solomon Kurz’s edition where he walked through each example in the book using brms. work! Please check [that] too. (But make sure that you come back here. We are not done yet). I made some changes because his code doesn’t match the book version that I have. Great d3 &lt;- d2 %&gt;% mutate(B = B) b4.8 &lt;- brm(data = d3, family = gaussian, temp ~ 1 + B, prior = c(prior(normal(6, 10), class = Intercept), prior(normal(0, 1), class = b), prior(exponential(1), class = sigma)), iter = 2000, warmup = 1000, chains = 4, cores = 4, seed = 4) ## Warning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable. ## Running the chains for more iterations may help. See ## http://mc-stan.org/misc/warnings.html#bulk-ess We fit the model above. let’s see if it matches the book. f &lt;- fitted(b4.8) f %&gt;% data.frame() %&gt;% bind_cols(d2) %&gt;% ggplot(aes(x = year, y = temp, ymin = Q2.5, ymax = Q97.5)) + geom_vline(xintercept = knot_list, color = &quot;white&quot;, alpha = 0.5) + geom_hline(yintercept = fixef(b4.8)[1, 1], color = &quot;white&quot;, linetype = 2) + geom_point(color = &quot;dodgerblue&quot;, alpha = 0.5) + geom_ribbon(fill = &quot;black&quot;, alpha = 0.6) + labs(x = &quot;year&quot;, y = &quot;March Temperature&quot;) Yupp! That’s the plot I see in the book. Yes, all credit goes to BRMS. We did nothing. Our task begins here. Let’s see the Stan code that the BRMS created for us. stancode(b4.8) ## // generated with brms 2.15.0 ## functions { ## } ## data { ## int&lt;lower=1&gt; N; // total number of observations ## vector[N] Y; // response variable ## int&lt;lower=1&gt; K; // number of population-level effects ## matrix[N, K] X; // population-level design matrix ## int prior_only; // should the likelihood be ignored? ## } ## transformed data { ## int Kc = K - 1; ## matrix[N, Kc] Xc; // centered version of X without an intercept ## vector[Kc] means_X; // column means of X before centering ## for (i in 2:K) { ## means_X[i - 1] = mean(X[, i]); ## Xc[, i - 1] = X[, i] - means_X[i - 1]; ## } ## } ## parameters { ## vector[Kc] b; // population-level effects ## real Intercept; // temporary intercept for centered predictors ## real&lt;lower=0&gt; sigma; // residual SD ## } ## transformed parameters { ## } ## model { ## // likelihood including constants ## if (!prior_only) { ## target += normal_id_glm_lpdf(Y | Xc, Intercept, b, sigma); ## } ## // priors including constants ## target += normal_lpdf(b | 0, 1); ## target += normal_lpdf(Intercept | 6, 10); ## target += exponential_lpdf(sigma | 1); ## } ## generated quantities { ## // actual population-level intercept ## real b_Intercept = Intercept - dot_product(means_X, b); ## } Hmm, at first glance this one looks much complicated than the models that we coded so far. Actually it’s not the case. Let’s break it down. &#39;&#39;&#39; data { int&lt;lower=1&gt; N; // total number of observations vector[N] Y; // response variable int&lt;lower=1&gt; K; // number of population-level effects matrix[N, K] X; // population-level design matrix int prior_only; // should the likelihood be ignored? } &#39;&#39;&#39; Paul Bürkner -the creater of the package- already put there explanations. Y is our temperature variable.K is number of knots in our case. X is the design matrix with N number of rows and K(knots) number of columns. The last line is telling stan program about the purpose of the task. If you are using stan model only for making prior predictive simulations, then the way is to is by tweaking that int prior_only; part. &#39;&#39;&#39; } transformed data { int Kc = K - 1; matrix[N, Kc] Xc; // centered version of X without an intercept vector[Kc] means_X; // column means of X before centering for (i in 2:K) { means_X[i - 1] = mean(X[, i]); Xc[, i - 1] = X[, i] - means_X[i - 1]; } &#39;&#39;&#39; As the name hints, Transformed parameters is the block where you make transformations on the data inside the stan model. Basically BRMS is centering it. We will not use this block. &#39;&#39;&#39; parameters { vector[Kc] b; // population-level effects real Intercept; // temporary intercept for centered predictors real&lt;lower=0&gt; sigma; // residual SD } &#39;&#39;&#39; The parameters block is important for us. Pay attention to types of b - vector - and alpha -real- This information is super important. Up next is, the model block &#39;&#39;&#39; model { // likelihood including constants if (!prior_only) { target += normal_id_glm_lpdf(Y | Xc, Intercept, b, sigma); } // priors including constants target += normal_lpdf(b | 0, 1); target += normal_lpdf(Intercept | 6, 10); target += exponential_lpdf(sigma | 1); } &#39;&#39;&#39; So what does the first line imply? As we discussed above, it basically tells the stan program, in cases where the model is not prior predictive simulations (the int prior only part in the data block), then use this likelihood to proceed. Otherwise, ignore the likelihood and proceed. Since we are interested in the likelihood, lets see how brms constructs it for splines. target += normal_id_glm_lpdf(Y | Xc, Intercept, b, sigma); is the key element here. The rest is given us by McElreath. When we check stan user’s guide, there it explains what this one does as: real normal_id_glm_lpdf(vector y | matrix x, real alpha, vector beta, real sigma) The log normal probability density of y given location alpha+x*beta and scale sigma, where a constant &gt;intercept alpha and sigma is used for all observations. The number of rows of the independent &gt;variable matrix x needs to match the length of the dependent variable vector y and the number of &gt;columns of x needs to match the length of the weight vector beta Another important observation is that BRMS uses target += notation in the model block. It’s basically nothing fundamentally different than what we have been doing. In plain English, target notation says, “hey, I have a target and each time I use the target += notation, I am incrementally updating the information about that target.” So now we know what it does internally and we can use it in our own version. But of course we have to create data for stan. spline_data &lt;- list(N =NROW(d3), t = d3$temp, knots = NCOL(d3$B), X = d3$B) The model we learned from BRMS is data { int&lt;lower=1&gt; N; vector[N] t; int&lt;lower=1&gt; knots; matrix[N, knots] X; } parameters { vector[knots] b; real alpha; real&lt;lower=0&gt; sigma; } transformed parameters{ vector[N] mu = alpha + X * b; } model { target += normal_id_glm_lpdf(t | X, alpha, b, sigma); target += normal_lpdf(b | 0, 1); target += normal_lpdf(alpha | 6, 10); target += exponential_lpdf(sigma | 1); } Do you notice that I used transformed parameters block. I believe up to this point we have seen examples of how to reverse engineer a Golem. So, we don’t have to calculate the posterior distribution of the \\(\\mu\\) from the parameters manually. The code inside the transformed parameters block already does that for us. Then it’s going to be much easier to proceed. Super Important Note: Order matters here. I have written it as vector[N] mu = alpha + X * b;. If you write it as vector[N] mu = alpha + b * X;, then, stan will throw out a big chunk of error. Remember, I said pay attention to the types that we passed for the parameters. * operator is okay with matrix to vector multiplication. But the other way around is not permitted. Try playing with it and see the error by yourself. Let’s sample from it. #fit fit_experimental_spline &lt;- sampling(experimental_spline.stan, spline_data, iter=1000, chain=2, cores=4) ## Warning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable. ## Running the chains for more iterations may help. See ## http://mc-stan.org/misc/warnings.html#bulk-ess ## Warning: Tail Effective Samples Size (ESS) is too low, indicating posterior variances and tail quantiles may be unreliable. ## Running the chains for more iterations may help. See ## http://mc-stan.org/misc/warnings.html#tail-ess post_experimental &lt;- fit_experimental_spline%&gt;% gather_draws(mu[i]) %&gt;% mean_qi() %&gt;% rename(yhat =.value, lower = .lower, upper = .upper) post_experimental$year &lt;- d3$year post_experimental$temp &lt;- d3$temp ggplot(post_experimental) + geom_point(aes(x = year, y= temp), alpha=0.5, color=&quot;dodgerblue&quot;) + geom_ribbon(aes(x = year, y= temp, ymin=lower, ymax=upper), alpha=0.6) Wouw. We just beat the end-level boss. But if you are interested, there is another way of beating it. Let me show you quickly data { int&lt;lower=1&gt; N; vector[N] t; int&lt;lower=1&gt; knots; matrix[N, knots] X; } parameters { vector[knots] b; real alpha; real&lt;lower=0&gt; sigma; } transformed parameters{ vector[N] mu = alpha + X * b; } model { t ~ normal(mu, sigma); b ~ normal(0, 1); alpha ~ normal(6, 10); sigma ~ exponential(1); } We not only got rid of target += notation. We used t ~ normal(mu, sigma);, which was originally given us by McElrath. I like this one better because it’s a direct translation of the mathematical model fit_spline &lt;- sampling(spline_model.stan, spline_data, iter=1000, chain=2, cores=4) ## Warning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable. ## Running the chains for more iterations may help. See ## http://mc-stan.org/misc/warnings.html#bulk-ess ## Warning: Tail Effective Samples Size (ESS) is too low, indicating posterior variances and tail quantiles may be unreliable. ## Running the chains for more iterations may help. See ## http://mc-stan.org/misc/warnings.html#tail-ess plot_spline &lt;- fit_spline%&gt;%gather_draws(mu[i]) %&gt;% mean_qi() %&gt;% rename(yhat = .value) plot_spline$year &lt;- d3$year plot_spline$temp &lt;- d3$temp ggplot(data= plot_spline) + geom_point(aes(x=year, y=temp), color=&quot;dodgerblue&quot;, alpha=0.5) + geom_ribbon(aes(x=year, y=yhat, ymin=.lower, ymax=.upper), alpha=0.6) Yes, all the same. So we are done with the first chapter. See you in the next one. "],["the-many-variables-the-spurious-waffles.html", "Chapter 2 The Many Variables &amp; The Spurious Waffles 2.1 Spurious Association 2.2 Masked Relationship 2.3 Categorical Variables", " Chapter 2 The Many Variables &amp; The Spurious Waffles \\[\\newcommand{\\ci}{\\perp\\!\\!\\!\\perp}\\] library(rethinking) library(dplyr) library(rstan) library(brms) library(ggplot2) library(tidybayes) library(tidyverse) library(patchwork) library(brms) library(dagitty) library(ggdag) 2.1 Spurious Association In the first section of this chapter we are going to deal with the milk data. Let’s load it and apply desired tranformations on it. #load data and copy data(WaffleDivorce) d &lt;- WaffleDivorce As data contained missing values, we decided to use only the cases for our three variables. After we make sure that there’s nothing missing. Let’s move on with standardization #standardise the variables d$A &lt;- ( d$MedianAgeMarriage - mean(d$MedianAgeMarriage) ) / sd(d$MedianAgeMarriage) d$M &lt;- ( d$Marriage - mean(d$Marriage) ) / sd(d$Marriage) d$D &lt;- (d$Divorce - mean (d$Divorce) ) / sd(d$Divorce) In the book McElrath used scale function but I wanted to do it manually. Basicall standardization is: \\[ z_i = \\frac{ X_i - \\bar{X}} {sd(X)} \\] resulting is the standardized vector Before doing anything with our standardized variables let’s fit those two models in McElreath’s double plot First model is \\[\\ \\ \\ \\ \\ \\ \\ \\ D_i \\sim \\mathrm{Normal}(\\mu_i, \\sigma) \\\\ \\mu_i = \\alpha + \\beta_{A} A_i \\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\alpha \\sim \\mathrm{Normal(0, 0.2)} \\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\beta \\sim \\mathrm{Normal(0, 0.5)} \\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\sigma \\sim \\mathrm{Exponential(1)}\\] Stan data for the right handside plot dat_5_1_a &lt;- list(N=NROW(d), X = d$A, D = d$D) data { int&lt;lower=0&gt; N; vector[N] X; vector[N] D; } parameters { real alpha; real beta; real&lt;lower=0&gt; sigma; } transformed parameters{ vector[N] mu = alpha + beta * X; } model { D ~ normal(mu, sigma); alpha ~ normal(0, 0.2); beta ~ normal(0, 0.5); sigma ~ exponential(1); } #Sampling fit_5_1_a &lt;- sampling(double_plot_model.stan, dat_5_1_a, iter=1000, chains=2, cores=4) d_right_plot &lt;- fit_5_1_a %&gt;% gather_draws(mu[i]) %&gt;% mean_qi() %&gt;% rename(mu = .value, lower = .lower, upper = .upper) d_right_plot$D &lt;- scale(d$Divorce) d_right_plot$A &lt;- scale(d$MedianAgeMarriage) # Aesthetics X rescale_x &lt;- seq(-2, 2, by=1) x_labels &lt;- rescale_x * sd(d$MedianAgeMarriage) + mean(d$MedianAgeMarriage) # Aesthetics Y rescale_y &lt;- seq(-2, 2, by=1) y_labels &lt;- rescale_x * sd(d$Divorce) + mean(d$Divorce) ggplot(d_right_plot) + geom_point(aes(x=A , y=D)) + geom_ribbon(aes(x = A, ymin=lower, ymax=upper), alpha=0.5) + geom_line(aes(x=A , y=mu),size=2) + scale_x_continuous(breaks = rescale_x, labels = round(x_labels, 0)) + scale_y_continuous(breaks = rescale_y, labels = round(y_labels, 0)) + xlab(&quot;Median Age at Marriage&quot;) + ylab(&quot;Divorce Rate&quot;) And second Model \\[\\ \\ \\ \\ \\ \\ \\ \\ D_i \\sim \\mathrm{Normal}(\\mu_i, \\sigma) \\\\ \\mu_i = \\alpha + \\beta_{M} M_i \\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\alpha \\sim \\mathrm{Normal(0, 0.2)} \\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\beta \\sim \\mathrm{Normal(0, 0.5)} \\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\sigma \\sim \\mathrm{Exponential(1)}\\] Stan data for the right handside plot dat_5_1_b &lt;- list(N=NROW(d), X = d$M, D = d$D) Notice we are using same model with different data #Sampling fit_5_1_b &lt;- sampling(double_plot_model.stan, dat_5_1_b, iter=1000, chains=2, cores=4) d_left_plot &lt;- fit_5_1_b %&gt;% gather_draws(mu[i]) %&gt;% mean_qi() %&gt;% rename(mu = .value, lower = .lower, upper = .upper) d_left_plot$D &lt;- scale(d$Divorce) d_left_plot$M &lt;- scale(d$Marriage) # Aesthetics X rescale_x &lt;- seq(-2, 2, by=1) x_labels &lt;- rescale_x * sd(d$Marriage) + mean(d$Marriage) ggplot(d_left_plot) + geom_point(aes(x=M , y=D)) + geom_ribbon(aes(x = M, ymin=lower, ymax=upper), alpha=0.5) + geom_line(aes(x=M , y=mu),size=2) + scale_x_continuous(breaks = rescale_x, labels = round(x_labels, 0)) + scale_y_continuous(breaks = rescale_y, labels = round(y_labels, 0)) + xlab(&quot;Marriage Rate&quot;) + ylab(&quot;Divorce Rate&quot;) Yes we did the modelling but how about the priors? What do we know about them? Just like the last chapter, let’s use simulations to see what they tell us about our model before any data. prior_alpha &lt;- rnorm(100, 0, 0.2) prior_beta &lt;- rnorm(100, -0.25, 0.25) prior_sigma &lt;- rexp(100, 2) #plot them plot(NULL, xlim=range(d$A), ylim = range(d$D), xlab = &quot;Median age of marriage&quot;, ylab = &quot;Divorce Rate&quot;) mtext( &quot;constructed slopes for beta ~ dnorm(-0.25, 0.25)&quot; ) # label x &lt;- 1 # constant xbar &lt;- 1 # constant mean N &lt;- 100 # number of observations for (i in 1:N ) curve(prior_alpha[i] + prior_beta[i]*x, from = min(d$A), to=max(d$D), add = TRUE, col = col.alpha(&quot;black&quot;, 0.4)) They are in fact reasonable priors. But is setting reasonable priors and writing down good stan code is enough for making causal claims? No! As the McElreath spends decent amount of time explaining why in chapters 5 and 6 of the book, causal inference is something different. First let’s draw some DAGS to see how we conceptualize the relationships among our variables dag_coords &lt;- tibble(name = c(&quot;A&quot;, &quot;M&quot;, &quot;D&quot;), x = c(1, 3, 2), y = c(2, 2, 1)) dag_1 &lt;- dagify(M ~ A, D ~ A + M, coords = dag_coords) p_dag_1 &lt;- dag_1%&gt;% ggplot(aes(x = x, y = y, xend = xend, yend = yend)) + geom_dag_point(color = &quot;black&quot;, alpha = 1/4, size = 10) + geom_dag_text(color = &quot;black&quot;) + geom_dag_edges(edge_color = &quot;black&quot;) + scale_x_continuous(NULL, breaks = NULL, expand = c(.1, .1)) + scale_y_continuous(NULL, breaks = NULL, expand = c(.1, .1)) + theme_bw() + theme(panel.grid = element_blank()) p_dag_1 The dag above corresponds to 3 assumptions 1. A directly influences M 2. A directly influences D 3. M directly influences D 4. A indirectly influences D over M This is one way to depict a causal model. But we don’t have one causal explanation mechanism for this data. Think about for a while. Do you really think Marriage rate has direct influence on Divorce, or median age at marriage as being common cause of both marriage rate and Divorce, creates a spurious correlation between marriage rate and divorce? Let’s depict that one and try to find ways to answer this question. dag_2 &lt;- dagify(M ~ A, D ~ A, coords = dag_coords) p_dag_2 &lt;- dag_2%&gt;% ggplot(aes(x = x, y = y, xend = xend, yend = yend)) + geom_dag_point(color = &quot;black&quot;, alpha = 1/4, size = 10) + geom_dag_text(color = &quot;black&quot;) + geom_dag_edges(edge_color = &quot;black&quot;) + scale_x_continuous(NULL, breaks = NULL, expand = c(.1, .1)) + scale_y_continuous(NULL, breaks = NULL, expand = c(.1, .1)) + theme_bw() + theme(panel.grid = element_blank()) p_dag_2 For that one we have to check conditional independencies that each DAG assumes. First DAG has no conditional independency. However, second DAG says M should be conditionally independent of D. \\(D \\ci \\mathrm{M | D}\\) in formal notation. print(impliedConditionalIndependencies(dag_1)) Let’s use dagity for both dags impliedConditionalIndependencies(dag_2) ## D _||_ M | A Let’s try to summarize. The testable implications of the first DAG are that all pairs of vari- ables &gt;should be associated, whatever we condition on. The testable implications of the second DAG are that all pairs of variables should be associated, before conditioning on anything, but that D &gt;and M should be independent after conditioning on A. So the only implication that differs between &gt;these DAGs is the last one: D ⊥ M|A. In order to test this we need a statistical model. Here we build it. First the stan data dat_multiple &lt;- list(N=NROW(d), A = d$A, M = d$M, D = d$D) Stan model is going to be really similar to polynomial models. The only difference will be that we are not going to use the same variable again and again. Rather, our \\(\\beta\\)s will be associated with differen variables. Contrary to previous models we created, this time I will write an additional block which draws the predictions from the posterior. data{ int&lt;lower=1&gt; N; vector[N] A; vector[N] M; vector[N] D; } parameters{ real alpha; real beta_A; real beta_M; real&lt;lower=0&gt; sigma; } transformed parameters{ vector[N] mu = alpha + beta_A * A + beta_M * M; } model{ D ~ normal(mu, sigma); alpha ~ normal(0, 0.2); beta_M ~ normal(0, 0.5); beta_M ~ normal(0, 0.5); sigma ~ exponential(1); } generated quantities{ vector[N] yhat; for (i in 1:N) yhat[i] = normal_rng(mu[i], sigma); } The generated quantities block is designed for that purpose. Once you have the model, you can make stan all the manual work do for you. Basically what we told the Golem is, “hey, please create a vector of size N. For each row ranging from 1 to N, simulate from a normal distribution. In order to simulate from normal distribution you’ll naturally need a mean and standard deviation. Take each row of mu as mean and use sigma and standard deviation” #Sampling fit_multiple &lt;- sampling(model_multiple.stan, dat_multiple, iter=1000, chains=2, cores=4) Coefficient for A in single predictor model print(fit_5_1_a, pars=&quot;beta&quot;) ## Inference for Stan model: stan-1982640c4519. ## 2 chains, each with iter=1000; warmup=500; thin=1; ## post-warmup draws per chain=500, total post-warmup draws=1000. ## ## mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat ## beta -0.56 0 0.11 -0.78 -0.64 -0.56 -0.49 -0.34 1027 1 ## ## Samples were drawn using NUTS(diag_e) at Sat Jul 17 13:47:56 2021. ## For each parameter, n_eff is a crude measure of effective sample size, ## and Rhat is the potential scale reduction factor on split chains (at ## convergence, Rhat=1). coefficient for M in single predictor model print(fit_5_1_b, pars=&quot;beta&quot;) ## Inference for Stan model: stan-1982640c4519. ## 2 chains, each with iter=1000; warmup=500; thin=1; ## post-warmup draws per chain=500, total post-warmup draws=1000. ## ## mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat ## beta 0.35 0 0.13 0.09 0.26 0.35 0.44 0.58 801 1 ## ## Samples were drawn using NUTS(diag_e) at Sat Jul 17 13:48:01 2021. ## For each parameter, n_eff is a crude measure of effective sample size, ## and Rhat is the potential scale reduction factor on split chains (at ## convergence, Rhat=1). print(fit_multiple, pars=c(&quot;beta_A&quot;, &quot;beta_M&quot;)) ## Inference for Stan model: stan-1982d2a88ab. ## 2 chains, each with iter=1000; warmup=500; thin=1; ## post-warmup draws per chain=500, total post-warmup draws=1000. ## ## mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat ## beta_A -0.67 0.01 0.17 -1.00 -0.77 -0.66 -0.55 -0.36 629 1 ## beta_M -0.10 0.01 0.15 -0.42 -0.20 -0.10 0.00 0.18 575 1 ## ## Samples were drawn using NUTS(diag_e) at Sat Jul 17 13:48:07 2021. ## For each parameter, n_eff is a crude measure of effective sample size, ## and Rhat is the potential scale reduction factor on split chains (at ## convergence, Rhat=1). Look how coefficient for M wildy reduced. More importantly the credible interval is containing the zero now. So, the testable implication of the second was confirmed. Since the first one didn’t have this implication, it’s out. In the section where McElreath shows us how to dig deeper the multivariate posterior, he also spent time on predictor residual plots. Here I will skip that. Maybe I’ll add it when I am done with this project. For the time being I will only do posterior predictions and counterfactual plots 2.1.1 Posterior Prediction Plots p_dat_mult &lt;- fit_multiple%&gt;% gather_draws(mu[i]) %&gt;% mean_qi() %&gt;% rename(mu = .value) yhat &lt;- fit_multiple%&gt;%gather_draws(yhat[i]) %&gt;% mean_qi() %&gt;% rename(yhat = .value) p_dat_mult$observed &lt;- d$D p_dat_mult$yhat &lt;- yhat$yhat ggplot(p_dat_mult, aes(x=observed, y=yhat, ymin = .lower, ymax = .upper)) + geom_point() + geom_pointrange() + geom_abline(intercept = 0, slope = 1, linetype = &#39;dashed&#39;) 2.1.2 Counterfactual Plots Now we come to a specific point where we have to fit 2 models at the same time inside one stan file. First of all, is it possible? Well, if it’s possible for BRMS, then it should be possible for us too. For this task it’s not super necessary to learn from BRMS because this time the task is relatively easy. All we have to do is specifying parameters in a naming convention that when we are using them in different calculations, we should know which parameter is from which model. The rest is merging two models that we already fit. However, since I want to encourage the readers to get the habit of learning from BRMS when in doubt, I will show you how BRMS constructs it. let’s fit the brms model Again, I quickly copy paste it from Solomon’s book. d_model &lt;- bf(D ~ 1 + A + M) m_model &lt;- bf(M ~ 1 + A) #model b5.3_A &lt;- brm(data = d, family = gaussian, d_model + m_model + set_rescor(FALSE), prior = c(prior(normal(0, 0.2), class = Intercept, resp = D), prior(normal(0, 0.5), class = b, resp = D), prior(exponential(1), class = sigma, resp = D), prior(normal(0, 0.2), class = Intercept, resp = M), prior(normal(0, 0.5), class = b, resp = M), prior(exponential(1), class = sigma, resp = M)), iter = 2000, warmup = 1000, chains = 4, cores = 4, seed = 5) print(stancode(b5.3_A)) ## // generated with brms 2.15.0 ## functions { ## } ## data { ## int&lt;lower=1&gt; N; // total number of observations ## int&lt;lower=1&gt; N_D; // number of observations ## vector[N_D] Y_D; // response variable ## int&lt;lower=1&gt; K_D; // number of population-level effects ## matrix[N_D, K_D] X_D; // population-level design matrix ## int&lt;lower=1&gt; N_M; // number of observations ## vector[N_M] Y_M; // response variable ## int&lt;lower=1&gt; K_M; // number of population-level effects ## matrix[N_M, K_M] X_M; // population-level design matrix ## int prior_only; // should the likelihood be ignored? ## } ## transformed data { ## int Kc_D = K_D - 1; ## matrix[N_D, Kc_D] Xc_D; // centered version of X_D without an intercept ## vector[Kc_D] means_X_D; // column means of X_D before centering ## int Kc_M = K_M - 1; ## matrix[N_M, Kc_M] Xc_M; // centered version of X_M without an intercept ## vector[Kc_M] means_X_M; // column means of X_M before centering ## for (i in 2:K_D) { ## means_X_D[i - 1] = mean(X_D[, i]); ## Xc_D[, i - 1] = X_D[, i] - means_X_D[i - 1]; ## } ## for (i in 2:K_M) { ## means_X_M[i - 1] = mean(X_M[, i]); ## Xc_M[, i - 1] = X_M[, i] - means_X_M[i - 1]; ## } ## } ## parameters { ## vector[Kc_D] b_D; // population-level effects ## real Intercept_D; // temporary intercept for centered predictors ## real&lt;lower=0&gt; sigma_D; // residual SD ## vector[Kc_M] b_M; // population-level effects ## real Intercept_M; // temporary intercept for centered predictors ## real&lt;lower=0&gt; sigma_M; // residual SD ## } ## transformed parameters { ## } ## model { ## // likelihood including constants ## if (!prior_only) { ## target += normal_id_glm_lpdf(Y_D | Xc_D, Intercept_D, b_D, sigma_D); ## target += normal_id_glm_lpdf(Y_M | Xc_M, Intercept_M, b_M, sigma_M); ## } ## // priors including constants ## target += normal_lpdf(b_D | 0, 0.5); ## target += normal_lpdf(Intercept_D | 0, 0.2); ## target += exponential_lpdf(sigma_D | 1); ## target += normal_lpdf(b_M | 0, 0.5); ## target += normal_lpdf(Intercept_M | 0, 0.2); ## target += exponential_lpdf(sigma_M | 1); ## } ## generated quantities { ## // actual population-level intercept ## real b_D_Intercept = Intercept_D - dot_product(means_X_D, b_D); ## // actual population-level intercept ## real b_M_Intercept = Intercept_M - dot_product(means_X_M, b_M); ## } It’s long but pretty simple. If you look at the data block you can see that brms used compact notation. Solid way of declaring the data but not the only way. If you are already a person with advanced statistics literacy you may find it comfortable this way too. But for me, I prefer writing it explicitly. What I want you to see whether is there something abnormal in the model and parameters block. Thankfully no, it’s just parameters piled up on top of each other. So, if this is the way to go, I believe we can continue with the simpler approach we have. data { int&lt;lower=1&gt; N; vector[N] A; vector[N] M; vector[N] D; } parameters{ //First model real alpha_model_1; real beta_A_model_1; real beta_M_model_1; real&lt;lower=0&gt; sigma_model_1; //betas real alpha_model_2; real beta_A_model_2; real&lt;lower=0&gt; sigma_model_2; } transformed parameters { // mu of first model vector[N] mu_model_1 = alpha_model_1 + beta_A_model_1 * A + beta_M_model_1 * M; // mu of second model vector[N] mu_model_2 = alpha_model_2 + beta_A_model_2 * A; } model { // modelling the response and setting priors for the params in the first model D ~ normal(mu_model_1, sigma_model_1); alpha_model_1~normal(0, 0.2); beta_A_model_1 ~ normal(0, 0.5); beta_M_model_1 ~ normal(0, 0.5); sigma_model_1 ~ exponential(1); // modelling the response and setting priors for the params in the second model M ~normal(mu_model_2, sigma_model_2); alpha_model_2 ~ normal(0, 0.2); beta_A_model_2 ~ normal(0, 0.5); } generated quantities { vector[N] yhat_model_1; vector[N] yhat_model_2; for (i in 1:N) yhat_model_1[i] = normal_rng(mu_model_1[i], sigma_model_1); for (i in 1:N) yhat_model_2[i] = normal_rng(mu_model_2[i], sigma_model_2); } The generated quantities block above is completely unnecessary for the following example fit_cf &lt;- sampling(model_counterfactual.stan, dat_multiple, chains=2, cores=4, iter=1000) posterior_cf &lt;- as.data.frame(fit_cf) # new data for intervention A_manipulated &lt;- seq(from = -2, to = 2, length.out = 30) # intervening A -&gt; M # function to simulate the mean simulate_mu_A_M &lt;- function(x) with(posterior_cf, alpha_model_2 + beta_A_model_2 *x) # Function to simulate predictions sim_prediction_A_M &lt;- function(x) rnorm(10000, mean =with(posterior_cf, alpha_model_2 + beta_A_model_2 *x), sd = posterior_cf$sigma_model_2) sapply(A_manipulated , sim_prediction_A_M) %&gt;% as.data.frame() %&gt;% rename_all(function(x) A_manipulated) %&gt;% mutate(iteration = row_number()) %&gt;% gather(A_manipulated, yhat, -iteration) %&gt;% group_by(A_manipulated) %&gt;% mutate(hpdi_l = HDInterval::hdi(yhat, credMass=0.8)[1], hpdi_h = HDInterval::hdi(yhat, credMass=0.8)[2], yhat_mu = mean(yhat))%&gt;% ungroup()%&gt;% mutate(A_manipulated = as.numeric(A_manipulated), yhat = as.numeric(yhat), yhat_mu = as.numeric(yhat_mu))%&gt;% ggplot() + geom_ribbon(aes(x=round(A_manipulated, 2), y=yhat_mu, ymin=hpdi_l, ymax=hpdi_h), alpha=0.3) + geom_line(aes(x=A_manipulated, y=yhat_mu), color=&quot;black&quot;, size=1.5) + xlab(&quot;Manipulated A&quot;) + ylab(&quot;Counterfactual M&quot;)+ ggtitle(&quot;Total counterfactual effect of A on M&quot;) sim_prediction_A_D &lt;- function(x, x2) rnorm(10000, mean =with(posterior_cf, alpha_model_1 + beta_A_model_1 *x + beta_M_model_1 * x2), sd = posterior_cf$sigma_model_1) sapply(A_manipulated , sim_prediction_A_D, 0) %&gt;% as.data.frame() %&gt;% rename_all(function(x) A_manipulated) %&gt;% mutate(iteration = row_number()) %&gt;% gather(A_manipulated, yhat, -iteration) %&gt;% group_by(A_manipulated) %&gt;% mutate(hpdi_l = HDInterval::hdi(yhat, credMass=0.8)[1], hpdi_h = HDInterval::hdi(yhat, credMass=0.8)[2], yhat_mu = mean(yhat))%&gt;% ungroup()%&gt;% mutate(A_manipulated = as.numeric(A_manipulated), yhat = as.numeric(yhat), yhat_mu = as.numeric(yhat_mu))%&gt;% ggplot() + geom_ribbon(aes(x=round(A_manipulated, 2), y=yhat_mu, ymin=hpdi_l, ymax=hpdi_h), alpha=0.3) + geom_line(aes(x=A_manipulated, y=yhat_mu), color=&quot;black&quot;, size=1.5) + xlab(&quot;Manipulated A&quot;) + ylab(&quot;Counterfactual D&quot;) + ggtitle(&quot;Counterfactual Effect of A on D&quot;) # Manipulated M M_manipulated &lt;- list(M_manipulated = seq(from=-2, to=2, length.out = 30), A = seq(from=0, to=0, length.out = 30)) # Simulate predictions for M-&gt;D sim_prediction_M_D &lt;- function(x, x_constant) rnorm(10000, mean = with(posterior_cf, alpha_model_1 + beta_M_model_1 *x + beta_A_model_1 * x_constant), sd=posterior_cf$sigma_model_1) sapply(M_manipulated$M_manipulated, sim_prediction_M_D, 0) %&gt;% as.data.frame() %&gt;% rename_all(function(x) M_manipulated$M_manipulated) %&gt;% mutate(iteration = row_number()) %&gt;% gather(M, D, -iteration) %&gt;% group_by(M) %&gt;% mutate(pi_l = rethinking::PI(D, prob=0.89)[1], pi_h = rethinking::PI(D, prob=0.89)[2], yhat_mu = mean(D))%&gt;% ungroup()%&gt;% mutate(M=as.numeric(M), D=as.numeric(D), yhat_mu = as.numeric(yhat_mu)) %&gt;% ggplot() + geom_ribbon(aes(x=M, y=yhat_mu, ymin=pi_l, ymax=pi_h), alpha=0.3) + geom_line(aes(x=M, y=yhat_mu), color=&quot;black&quot;, size=1.5) 2.2 Masked Relationship data(milk) d &lt;- milk # Drop unused cases d &lt;- d%&gt;%select(kcal.per.g, mass, neocortex.perc) dcc &lt;- d[complete.cases(d),] #standardise variables of interest dcc$K &lt;- ( dcc$kcal.per.g - mean(dcc$kcal.per.g )) / sd(dcc$kcal.per.g) dcc$M &lt;- ( dcc$mass - mean(dcc$mass) ) / sd(dcc$mass) dcc$N &lt;- ( dcc$neocortex.perc - mean(dcc$neocortex.perc)) / sd(dcc$neocortex.perc) The building block of the mode is as follows \\[K_i \\sim \\mathrm{Normal}(\\mu_i , \\sigma)\\\\ \\mu_i = \\alpha + \\beta_N N_i\\] But what about the priors? Let’s pick Normal(0,1) for the beginning. # prior predictive simulations N &lt;- 100 pr_alpha &lt;- rnorm(N, 0, 1) pr_beta_N &lt;- rnorm(N, 0, 1) pr_sigma &lt;- rexp(N, 1) xseq &lt;- c(-2, 2) pr_mu &lt;- pr_alpha + pr_beta_N * 1 pr_pred &lt;- rnorm(N, mean = pr_alpha + pr_beta_N * 1, sd = pr_sigma) plot(NULL, xlim=xseq, ylim=xseq) x=1 for (i in 1:N ) curve(pr_alpha[i] + pr_beta_N[i]*x , from = -2, to=2, add = TRUE, col = col.alpha(&quot;black&quot;, 0.2)) # terrible prior Seems horribe. Let’s use the ones from the previous chapter. pr_alpha &lt;- rnorm(N, 0, 0.2) pr_beta_N &lt;- rnorm(N, 0, 0.5) xseq &lt;- c(-2, 2) x &lt;- 1 plot(NULL, xlim=xseq, ylim=xseq) for (i in 1:N) curve(pr_alpha[i] + pr_beta_N[i] * x, from = -2, to =2, add=T, col = col.alpha(&quot;black&quot;, 0.2)) # reasonable prior Prepare the stan model dat_neo &lt;- list(N = NROW(dcc), K = dcc$K, Neo = dcc$N) And the stan program data{ int&lt;lower=1&gt; N; vector[N] Neo; vector[N] K; } parameters{ real alpha; real beta_Neo; real&lt;lower=0&gt; sigma; } transformed parameters{ vector[N] mu = alpha + beta_Neo * Neo; } model{ K ~ normal(mu,sigma); alpha ~ normal(0, 0.2); beta_Neo ~ normal(0, 0.2); sigma ~ exponential(1); } fit_neo &lt;- sampling(milk_neo.stan, dat_neo, chains=2, cores=4, iter=1000) print(fit_neo, pars = c(&quot;alpha&quot;, &quot;beta_Neo&quot;, &quot;sigma&quot;)) ## Inference for Stan model: stan-19823290a60a. ## 2 chains, each with iter=1000; warmup=500; thin=1; ## post-warmup draws per chain=500, total post-warmup draws=1000. ## ## mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat ## alpha 0.00 0.01 0.14 -0.28 -0.09 0.00 0.10 0.27 775 1 ## beta_Neo 0.06 0.00 0.15 -0.25 -0.04 0.05 0.15 0.37 1040 1 ## sigma 1.02 0.01 0.18 0.75 0.89 0.99 1.12 1.46 552 1 ## ## Samples were drawn using NUTS(diag_e) at Sat Jul 17 13:48:41 2021. ## For each parameter, n_eff is a crude measure of effective sample size, ## and Rhat is the potential scale reduction factor on split chains (at ## convergence, Rhat=1). p_dat_neo &lt;- fit_neo%&gt;% gather_draws(mu[i]) %&gt;% mean_qi() %&gt;% rename(mu = .value) p_dat_neo$neo &lt;- dcc$N p_dat_neo$K &lt;- dcc$K p_neo &lt;-ggplot(p_dat_neo, aes(x=neo, y=K)) + geom_point() + geom_ribbon(aes(x=neo, y=mu, ymin=.lower, ymax=.upper), alpha=0.2) + geom_line(aes(x=neo, y=mu), size=2) + xlab(&quot;neo cortex percent (std)&quot;) + ylab(&quot;kilocal per grams (std)&quot;) # log standardise the mass dcc$logmass &lt;- ( log(dcc$mass) - mean( log(dcc$mass) ) ) / sd(log(dcc$mass)) # stan data dat_mass &lt;- list(N = NROW(dcc), Mass = dcc$logmass, K = dcc$K) data{ int&lt;lower=1&gt; N; vector[N] Mass; vector[N] K; } parameters{ real alpha; real beta_Mass; real&lt;lower=0&gt; sigma; } transformed parameters{ vector[N] mu = alpha + beta_Mass * Mass; } model{ K ~ normal(mu, sigma); alpha ~ normal(0, 0.2); beta_Mass ~ normal(0, 0.5); sigma ~ exponential(1); } fit_mass &lt;- sampling(milk_mass.stan, dat_mass, chains=2, cores=4, iter=1000) print(fit_mass, pars = c(&quot;alpha&quot;, &quot;beta_Mass&quot;, &quot;sigma&quot;)) ## Inference for Stan model: stan-1982726e0f64. ## 2 chains, each with iter=1000; warmup=500; thin=1; ## post-warmup draws per chain=500, total post-warmup draws=1000. ## ## mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat ## alpha 0.00 0.00 0.15 -0.30 -0.11 -0.01 0.10 0.30 942 1.00 ## beta_Mass -0.29 0.01 0.23 -0.74 -0.44 -0.29 -0.14 0.18 781 1.00 ## sigma 0.99 0.01 0.18 0.72 0.86 0.96 1.10 1.40 529 1.01 ## ## Samples were drawn using NUTS(diag_e) at Sat Jul 17 13:48:47 2021. ## For each parameter, n_eff is a crude measure of effective sample size, ## and Rhat is the potential scale reduction factor on split chains (at ## convergence, Rhat=1). p_dat_mass &lt;- fit_mass%&gt;% gather_draws(mu[i])%&gt;% mean_qi()%&gt;% rename(post_mu = .value) p_dat_mass$K &lt;- dcc$K p_dat_mass$logmass &lt;- dcc$logmass p_mass &lt;- ggplot(p_dat_mass, aes(x=logmass, y=K)) + geom_point() + geom_ribbon(aes(x=logmass, y=post_mu, ymin=.lower, ymax=.upper), alpha = 0.2) + geom_line(aes(x=logmass, y=post_mu), size=2) + xlab(&quot;log body mass (std)&quot;) + ylab(&quot;kilocal per grams (std)&quot;) p_neo + p_mass ### Multivariate Model dat_multivariate &lt;- list(N = NROW(dcc), K = dcc$K, Mass = dcc$logmass, Neo = dcc$N) data{ int&lt;lower=1&gt; N; vector[N] K; vector[N] Mass; vector[N] Neo; } parameters{ real alpha; real beta_Mass; real beta_Neo; real&lt;lower=0&gt; sigma; } transformed parameters{ vector[N] mu = alpha + beta_Mass * Mass + beta_Neo * Neo; } model{ K ~ normal(mu, sigma); alpha ~ normal(0, 0.2); beta_Mass ~ normal(0, 0.5); beta_Neo ~ normal(0, 0.5); sigma ~ exponential(1); } fit_multivariate &lt;- sampling(milk_multivariate.stan, dat_multivariate, cores=4, chains=2, iter=1000) print(fit_multivariate, pars = c(&quot;alpha&quot;, &quot;beta_Neo&quot;, &quot;beta_Mass&quot;, &quot;sigma&quot;)) ## Inference for Stan model: stan-19822fafcbfb. ## 2 chains, each with iter=1000; warmup=500; thin=1; ## post-warmup draws per chain=500, total post-warmup draws=1000. ## ## mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat ## alpha -0.01 0.00 0.14 -0.28 -0.10 -0.01 0.08 0.25 845 1 ## beta_Neo 0.57 0.01 0.25 0.04 0.42 0.58 0.73 1.04 437 1 ## beta_Mass -0.68 0.01 0.26 -1.20 -0.84 -0.69 -0.51 -0.13 490 1 ## sigma 0.80 0.01 0.17 0.55 0.69 0.78 0.89 1.22 567 1 ## ## Samples were drawn using NUTS(diag_e) at Sat Jul 17 13:48:53 2021. ## For each parameter, n_eff is a crude measure of effective sample size, ## and Rhat is the potential scale reduction factor on split chains (at ## convergence, Rhat=1). # posterior post_multivariate &lt;- as.data.frame(fit_multivariate) # CF_LOGMASS logmass_new &lt;- seq(from=min(dcc$M)-0.15 , to=max(dcc$M)+0.15, length.out = 30) sim_int_mass &lt;- function(x,y) rnorm(10000, mean = with(post_multivariate, alpha + beta_Neo * y + beta_Mass * x), sd = post_multivariate$sigma) p_cf_M &lt;-sapply(logmass_new, sim_int_mass, 0) %&gt;% as.data.frame() %&gt;% rename_all(function(x) logmass_new) %&gt;% mutate(iteration = row_number()) %&gt;% gather(logmass_new, yhat, -iteration) %&gt;% group_by(logmass_new) %&gt;% mutate(pi_l = rethinking::PI(yhat, prob=0.8)[1], pi_h = rethinking::PI(yhat, prob=0.8)[2], yhat_mu = mean(yhat)) %&gt;% ungroup() %&gt;% mutate(logmass_new = as.numeric(logmass_new), yhat = as.numeric(yhat), yhat_mu = as.numeric(yhat_mu))%&gt;% ggplot() + geom_ribbon(aes(x=round(logmass_new, 2), y=yhat_mu, ymin=pi_l, ymax=pi_h), alpha=0.2) + geom_line(aes(x=logmass_new, y=yhat_mu), size=2) + xlab(&quot;Manipulated log body mass&quot;) + ylab(&quot;Counterfactual kilocal per grams&quot;)+ ggtitle(&quot;Counterfactual holding N=0&quot;) #CF NEO neo_new = seq(from=min(dcc$N)-0.15 , to=max(dcc$N)+0.15, length.out = 30) sim_int_neo &lt;- function(x, y) rnorm(10000, mean = with(post_multivariate, alpha + beta_Neo * x + beta_Mass * y), sd =post_multivariate$sigma) p_cf_N &lt;- sapply(neo_new, sim_int_neo, 0) %&gt;% as.data.frame() %&gt;% rename_all(function(x) neo_new) %&gt;% mutate(iteration = row_number()) %&gt;% gather(neo_new, yhat, -iteration) %&gt;% group_by(neo_new) %&gt;% mutate(pi_l = rethinking::PI(yhat, prob=0.8)[1], pi_h = rethinking::PI(yhat, prob=0.8)[2], yhat_mu = mean(yhat)) %&gt;% mutate(neo_new = as.numeric(neo_new), yhat = as.numeric(yhat), yhat_mu = as.numeric(yhat_mu))%&gt;% ggplot() + geom_ribbon(aes(x=round(neo_new, 2), y=yhat_mu, ymin=pi_l, ymax=pi_h), alpha=0.2) + geom_line(aes(x=neo_new, y=yhat_mu), size=2) + xlab(&quot;Manipulated Neocortex %&quot;) + ylab(&quot;Counterfactual kilocal per grams&quot;)+ ggtitle(&quot;Counterfactual holding M=0&quot;) p_cf_M +p_cf_N 2.3 Categorical Variables #data data(&quot;Howell1&quot;) d &lt;- Howell1 precis(d) ## mean sd 5.5% 94.5% histogram ## height 138.2635963 27.6024476 81.108550 165.73500 ▁▁▁▁▁▁▁▂▁▇▇▅▁ ## weight 35.6106176 14.7191782 9.360721 54.50289 ▁▂▃▂▂▂▂▅▇▇▃▂▁ ## age 29.3443934 20.7468882 1.000000 66.13500 ▇▅▅▃▅▂▂▁▁ ## male 0.4724265 0.4996986 0.000000 1.00000 ▇▁▁▁▁▁▁▁▁▇ 2.3.1 Indicator Variables Problem with indicator variables mu_female &lt;- rnorm(1e4,178,20) mu_male &lt;- rnorm(1e4,178,20) + rnorm(1e4,0,10) precis( data.frame( mu_female , mu_male ) ) # mu male has wider tails ## mean sd 5.5% 94.5% histogram ## mu_female 178.0280 20.02640 145.6407 209.8339 ▁▁▁▃▇▇▂▁▁▁ ## mu_male 177.9283 22.28724 142.4056 213.9112 ▁▁▁▃▇▇▂▁▁▁ 2.3.2 Index Variables # Introducing INDEX VARIABLE d$sex &lt;- ifelse(d$male, 1, 2) str(d$sex) ## num [1:544] 1 2 2 1 2 1 2 1 2 1 ... stan model with index variable dat_index &lt;- list(N = NROW(d), S = d$sex, H = d$height, J = length(unique(d$sex))) If you are curious about J, please bear with me for a while. I’ll explain all. data{ int&lt;lower=1&gt; N; int&lt;lower=1&gt; J; int&lt;lower=1, upper=J&gt; S[N]; vector[N] H; } parameters { vector[J] alpha; real&lt;lower=0, upper=50&gt; sigma; } transformed parameters{ vector[N] mu = alpha[S]; } model{ H ~ normal(mu, sigma); alpha ~ normal(178, 20); } If you pay attention, this type of model construction is something different than what we have been doing so far. Especially the data block introduced us a new format of data declaration. I am not only talking about the J, there is also a difference in how we declared the S. Let’s break down what we did there. So, first of all, J tells the program that there’s an integer J that we are going to use throughout the modeling. Right after we declare it, there is int&lt;lower=1, upper=J&gt; S[N];. This partindicates that there are integers of S ranging from 1 to J(2). Each of them have subscripts that are ranging from 1 to N. This way the model learns the row number of each S observation. Following that, in the parameters block we are declaring alpha as a vector of J (2 in our example). Basically we told stan to create J alphas for us rather than a single one. And then we declared mu. vector[N] mu = alpha[S]; is different than our practice so far. What we mean by this notation is, “dear Golem, for each observation in the data, mu equals to alpha.” But let’s stop here for a while. Remember, we told stan to create J alphas for us. How can stan calculate the mu for a given observation when there are more than one alphas that she can chose? Answer is the subscript S. We tell Stan to use S as a map to know which alpha she should use. For each level of S, use corresponding alpha parameter for it. And since we already created mapping between S and rownumber N in the data block. Stan, then, can use this map to store corresponding mus for each observation in the data. The model block is the same. # sampling fit_index &lt;- sampling(model_index.stan, dat_index, iter=1000, chains=2, cores=4) And following result is matching the one in the books. In the book alphas numbered in reverse order but it doesn’t matter as long as you know the correspondence print(fit_index, pars = c(&quot;alpha&quot;, &quot;sigma&quot;)) ## Inference for Stan model: stan-198233251f4e. ## 2 chains, each with iter=1000; warmup=500; thin=1; ## post-warmup draws per chain=500, total post-warmup draws=1000. ## ## mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat ## alpha[1] 142.60 0.05 1.78 139.16 141.40 142.51 143.84 146.11 1232 1 ## alpha[2] 134.90 0.05 1.62 131.72 133.80 134.93 136.03 138.02 1127 1 ## sigma 27.49 0.03 0.83 25.92 26.93 27.45 28.04 29.33 910 1 ## ## Samples were drawn using NUTS(diag_e) at Sat Jul 17 13:49:06 2021. ## For each parameter, n_eff is a crude measure of effective sample size, ## and Rhat is the potential scale reduction factor on split chains (at ## convergence, Rhat=1). 2.3.3 Many Variables Now let’s continue with many categorical variables data(milk) d &lt;- milk # preview levels unique(d$clade) ## [1] Strepsirrhine New World Monkey Old World Monkey Ape ## Levels: Ape New World Monkey Old World Monkey Strepsirrhine # convert to numeric d$clade_id &lt;- as.integer(d$clade) #scale kcal d$K = (d$kcal.per.g - mean(d$kcal.per.g)) / sd(d$kcal.per.g) dat_many &lt;-list(N=NROW(d), C=d$clade_id, K=d$K, J=length(unique(d$clade_id))) data{ int&lt;lower=1&gt; N; int&lt;lower=1&gt; J; int&lt;lower=1, upper=J&gt; C[N]; vector[N] K; } parameters{ vector[J] alpha; real&lt;lower=0&gt; sigma; } transformed parameters{ vector[N] mu = alpha[C]; } model{ K ~ normal(mu, sigma); alpha ~ normal(0, 0.5); sigma ~ exponential(1); } fit_many_index &lt;- sampling(many_index.stan, dat_many, iter=1000, chains=2, cores=4) print(fit_many_index, pars=c(&quot;alpha&quot;, &quot;sigma&quot;)) ## Inference for Stan model: stan-1982573a0504. ## 2 chains, each with iter=1000; warmup=500; thin=1; ## post-warmup draws per chain=500, total post-warmup draws=1000. ## ## mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat ## alpha[1] -0.47 0.01 0.25 -0.92 -0.63 -0.47 -0.31 0.03 935 1 ## alpha[2] 0.35 0.01 0.22 -0.09 0.20 0.35 0.50 0.78 995 1 ## alpha[3] 0.65 0.01 0.27 0.12 0.47 0.66 0.84 1.20 1062 1 ## alpha[4] -0.55 0.01 0.27 -1.05 -0.74 -0.56 -0.36 0.03 1097 1 ## sigma 0.80 0.00 0.12 0.60 0.71 0.79 0.87 1.05 588 1 ## ## Samples were drawn using NUTS(diag_e) at Sat Jul 17 13:49:13 2021. ## For each parameter, n_eff is a crude measure of effective sample size, ## and Rhat is the potential scale reduction factor on split chains (at ## convergence, Rhat=1). Now let’s add one more variable. The House from Harry Potter set.seed(63) d$house &lt;- sample( rep(1:4,each=8) , size=nrow(d)) dat_many_1 &lt;- list(N = NROW(d), K = d$K, C = d$clade_id, J = length(unique(d$clade_id)), H = d$house, I = length(unique(d$house))) data{ int&lt;lower=1&gt; N; int&lt;lower=1&gt; J; int&lt;lower=1&gt; I; int&lt;lower=1, upper=J&gt; C[N]; int&lt;lower=1, upper=I&gt; H[N]; vector[N] K; } parameters{ vector[J] alpha_C; vector[I] alpha_H; real &lt;lower=0&gt; sigma; } transformed parameters{ vector[N] mu = alpha_C[C] + alpha_H[H]; } model{ K ~ normal(mu, sigma); alpha_C ~ normal(0, 0.5); alpha_H ~ normal(0, 0.5); sigma ~ exponential(1); } fit_many_1 &lt;- sampling(index_many_1.stan, dat_many_1, iter=1000, cores=4, chains=2) print(fit_many_1, c(&quot;alpha_H&quot;, &quot;alpha_C&quot;, &quot;sigma&quot;)) ## Inference for Stan model: stan-1982240f15db. ## 2 chains, each with iter=1000; warmup=500; thin=1; ## post-warmup draws per chain=500, total post-warmup draws=1000. ## ## mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat ## alpha_H[1] -0.09 0.01 0.29 -0.67 -0.29 -0.09 0.10 0.51 957 1 ## alpha_H[2] -0.18 0.01 0.31 -0.79 -0.39 -0.19 0.03 0.40 737 1 ## alpha_H[3] -0.15 0.01 0.29 -0.71 -0.34 -0.15 0.05 0.39 707 1 ## alpha_H[4] 0.48 0.01 0.31 -0.14 0.27 0.48 0.69 1.06 993 1 ## alpha_C[1] -0.40 0.01 0.29 -0.99 -0.59 -0.41 -0.21 0.17 683 1 ## alpha_C[2] 0.36 0.01 0.26 -0.13 0.19 0.36 0.53 0.89 588 1 ## alpha_C[3] 0.52 0.01 0.31 -0.09 0.31 0.53 0.72 1.08 878 1 ## alpha_C[4] -0.47 0.01 0.31 -1.03 -0.68 -0.47 -0.28 0.19 1030 1 ## sigma 0.78 0.00 0.11 0.61 0.69 0.76 0.85 1.03 921 1 ## ## Samples were drawn using NUTS(diag_e) at Sat Jul 17 13:49:19 2021. ## For each parameter, n_eff is a crude measure of effective sample size, ## and Rhat is the potential scale reduction factor on split chains (at ## convergence, Rhat=1). "]]
